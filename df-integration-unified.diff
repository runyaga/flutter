diff --git a/lib/core/router/app_router.dart b/lib/core/router/app_router.dart
index 82c12a6..6420cea 100644
--- a/lib/core/router/app_router.dart
+++ b/lib/core/router/app_router.dart
@@ -9,8 +9,9 @@ import 'package:soliplex_frontend/core/models/features.dart';
 import 'package:soliplex_frontend/core/models/route_config.dart';
 import 'package:soliplex_frontend/core/providers/shell_config_provider.dart';
 import 'package:soliplex_frontend/features/auth/auth_callback_screen.dart';
-// TEMPORARY: Debug agent screen — remove after F1 validation.
+// TEMPORARY: Debug screens — remove after validation.
 import 'package:soliplex_frontend/features/debug/debug_agent_screen.dart';
+import 'package:soliplex_frontend/features/debug/debug_dataframe_screen.dart';
 import 'package:soliplex_frontend/features/home/home_screen.dart';
 import 'package:soliplex_frontend/features/inspector/network_inspector_screen.dart';
 import 'package:soliplex_frontend/features/log_viewer/log_viewer_screen.dart';
@@ -327,7 +328,7 @@ final routerProvider = Provider<GoRouter>((ref) {
             return '/rooms/$roomId?thread=$threadId';
           },
         ),
-      // --- TEMPORARY: Debug agent run screen — remove after F1 validation ---
+      // --- TEMPORARY: Debug screens — remove after validation ---
       GoRoute(
         path: '/debug/agent',
         name: 'debug-agent',
@@ -336,6 +337,14 @@ final routerProvider = Provider<GoRouter>((ref) {
           body: const DebugAgentScreen(),
         ),
       ),
+      GoRoute(
+        path: '/debug/dataframe',
+        name: 'debug-dataframe',
+        pageBuilder: (context, state) => _staticPage(
+          title: const Text('DEBUG: DataFrame REPL'),
+          body: const DebugDataFrameScreen(),
+        ),
+      ),
       // --- END TEMPORARY ---
       if (features.enableSettings)
         GoRoute(
diff --git a/lib/features/debug/debug_dataframe_screen.dart b/lib/features/debug/debug_dataframe_screen.dart
new file mode 100644
index 0000000..c936b09
--- /dev/null
+++ b/lib/features/debug/debug_dataframe_screen.dart
@@ -0,0 +1,289 @@
+// TEMPORARY: Debug DataFrame REPL — remove after validation.
+// Cleanup: delete this file when no longer needed.
+
+import 'dart:convert';
+
+import 'package:flutter/material.dart';
+import 'package:flutter_riverpod/flutter_riverpod.dart';
+import 'package:soliplex_dataframe/soliplex_dataframe.dart';
+import 'package:soliplex_scripting/soliplex_scripting.dart';
+
+/// REPL-style debug screen for testing DataFrame operations directly.
+///
+/// Executes df_* host functions backed by a local [DfRegistry], without
+/// needing a Monty bridge or backend connection.
+class DebugDataFrameScreen extends ConsumerStatefulWidget {
+  const DebugDataFrameScreen({super.key});
+
+  @override
+  ConsumerState<DebugDataFrameScreen> createState() =>
+      _DebugDataFrameScreenState();
+}
+
+class _DebugDataFrameScreenState extends ConsumerState<DebugDataFrameScreen> {
+  final _inputController = TextEditingController();
+  final _outputLines = <_OutputLine>[];
+  final _scrollController = ScrollController();
+
+  late final DfRegistry _registry;
+  late final Map<String, _DfCommand> _commands;
+
+  @override
+  void initState() {
+    super.initState();
+    _registry = DfRegistry();
+    _commands = _buildCommands();
+    _addOutput('DataFrame REPL ready. Type "help" for commands.', _Kind.info);
+  }
+
+  @override
+  void dispose() {
+    _inputController.dispose();
+    _scrollController.dispose();
+    _registry.disposeAll();
+    super.dispose();
+  }
+
+  @override
+  Widget build(BuildContext context) {
+    return Column(
+      children: [
+        Container(
+          width: double.infinity,
+          padding: const EdgeInsets.all(8),
+          color: Colors.amber.shade100,
+          child: const Text(
+            '\u26A0 TEMPORARY SCAFFOLDING \u2014 remove after validation',
+            style: TextStyle(fontWeight: FontWeight.bold),
+          ),
+        ),
+        Expanded(
+          child: ListView.builder(
+            controller: _scrollController,
+            padding: const EdgeInsets.all(8),
+            itemCount: _outputLines.length,
+            itemBuilder: (_, i) => _buildLine(_outputLines[i]),
+          ),
+        ),
+        const Divider(height: 1),
+        Padding(
+          padding: const EdgeInsets.all(8),
+          child: Row(
+            children: [
+              const Text(
+                '\u276F ',
+                style: TextStyle(
+                  fontFamily: 'monospace',
+                  fontWeight: FontWeight.bold,
+                ),
+              ),
+              Expanded(
+                child: TextField(
+                  controller: _inputController,
+                  style: const TextStyle(fontFamily: 'monospace', fontSize: 13),
+                  decoration: const InputDecoration(
+                    hintText: 'df_create, df_head, df_filter, help ...',
+                    border: OutlineInputBorder(),
+                    isDense: true,
+                    contentPadding:
+                        EdgeInsets.symmetric(horizontal: 8, vertical: 10),
+                  ),
+                  onSubmitted: (_) => _execute(),
+                ),
+              ),
+              const SizedBox(width: 8),
+              IconButton(
+                icon: const Icon(Icons.send),
+                onPressed: _execute,
+              ),
+              IconButton(
+                icon: const Icon(Icons.delete_outline),
+                tooltip: 'Clear output',
+                onPressed: () => setState(_outputLines.clear),
+              ),
+            ],
+          ),
+        ),
+      ],
+    );
+  }
+
+  Widget _buildLine(_OutputLine line) {
+    final (color, prefix) = switch (line.kind) {
+      _Kind.input => (Colors.blue.shade700, '\u276F '),
+      _Kind.result => (Colors.green.shade800, '  '),
+      _Kind.error => (Colors.red.shade700, '! '),
+      _Kind.info => (Colors.grey.shade600, '# '),
+    };
+
+    return Padding(
+      padding: const EdgeInsets.symmetric(vertical: 1),
+      child: SelectableText(
+        '$prefix${line.text}',
+        style: TextStyle(
+          fontFamily: 'monospace',
+          fontSize: 12,
+          color: color,
+        ),
+      ),
+    );
+  }
+
+  void _addOutput(String text, _Kind kind) {
+    setState(() => _outputLines.add(_OutputLine(text, kind)));
+    WidgetsBinding.instance.addPostFrameCallback((_) {
+      if (_scrollController.hasClients) {
+        _scrollController.animateTo(
+          _scrollController.position.maxScrollExtent,
+          duration: const Duration(milliseconds: 100),
+          curve: Curves.easeOut,
+        );
+      }
+    });
+  }
+
+  Future<void> _execute() async {
+    final input = _inputController.text.trim();
+    if (input.isEmpty) return;
+    _inputController.clear();
+    _addOutput(input, _Kind.input);
+
+    if (input == 'help') {
+      _showHelp();
+      return;
+    }
+
+    // Parse: command_name arg1 arg2 ...  OR  command_name(json_args)
+    final parenMatch = RegExp(r'^(\w+)\((.+)\)$').firstMatch(input);
+    final spaceMatch = RegExp(r'^(\w+)\s*(.*)$').firstMatch(input);
+
+    final String name;
+    final String rawArgs;
+    if (parenMatch != null) {
+      name = parenMatch.group(1)!;
+      rawArgs = parenMatch.group(2)!;
+    } else if (spaceMatch != null) {
+      name = spaceMatch.group(1)!;
+      rawArgs = spaceMatch.group(2)!;
+    } else {
+      _addOutput('Could not parse command. Type "help".', _Kind.error);
+      return;
+    }
+
+    final cmd = _commands[name];
+    if (cmd == null) {
+      _addOutput('Unknown command: $name. Type "help".', _Kind.error);
+      return;
+    }
+
+    try {
+      final result = await cmd.execute(rawArgs);
+      _addOutput(result, _Kind.result);
+    } on Object catch (e) {
+      _addOutput('$e', _Kind.error);
+    }
+  }
+
+  void _showHelp() {
+    final buf = StringBuffer('Available commands:\n');
+    for (final entry in _commands.entries) {
+      buf.writeln('  ${entry.key.padRight(20)} ${entry.value.help}');
+    }
+    buf
+      ..writeln('\nExamples:')
+      ..writeln(
+        '  df_create([{"name":"Alice","age":30},{"name":"Bob","age":25}])',
+      )
+      ..writeln('  df_head 1')
+      ..writeln(
+        '  df_filter({"handle":1,"column":"age","op":">","value":28})',
+      )
+      ..writeln('  df_shape 1')
+      ..writeln('  df_columns 1')
+      ..writeln(r'  df_from_csv name,age\nAlice,30\nBob,25');
+    _addOutput(buf.toString(), _Kind.info);
+  }
+
+  Map<String, _DfCommand> _buildCommands() {
+    final fns = buildDfFunctions(_registry);
+    final byName = {for (final f in fns) f.schema.name: f};
+    final cmds = <String, _DfCommand>{};
+
+    for (final entry in byName.entries) {
+      final schema = entry.value.schema;
+      final handler = entry.value.handler;
+      final paramDesc = schema.params.map((p) => p.name).join(', ');
+      cmds[entry.key] = _DfCommand(
+        help: '($paramDesc) ${schema.description}',
+        execute: (rawArgs) async {
+          // Try JSON object parse first
+          Map<String, Object?> args;
+          if (rawArgs.startsWith('{')) {
+            args = Map<String, Object?>.from(
+              jsonDecode(rawArgs) as Map,
+            );
+          } else if (rawArgs.isEmpty) {
+            args = {};
+          } else {
+            // Single-arg shorthand: first param gets the parsed value
+            if (schema.params.isEmpty) {
+              args = {};
+            } else {
+              final firstParam = schema.params.first;
+              args = {firstParam.name: _parseSimpleArg(rawArgs)};
+            }
+          }
+
+          final result = await handler(args);
+          return _formatResult(result);
+        },
+      );
+    }
+
+    return cmds;
+  }
+
+  Object? _parseSimpleArg(String raw) {
+    final trimmed = raw.trim();
+    final asInt = int.tryParse(trimmed);
+    if (asInt != null) return asInt;
+    final asDouble = double.tryParse(trimmed);
+    if (asDouble != null) return asDouble;
+    if (trimmed == 'true') return true;
+    if (trimmed == 'false') return false;
+    if (trimmed == 'null') return null;
+    // Try JSON parse
+    try {
+      return jsonDecode(trimmed);
+    } on FormatException {
+      return trimmed;
+    }
+  }
+
+  String _formatResult(Object? result) {
+    if (result == null) return '(null)';
+    if (result is List) {
+      const encoder = JsonEncoder.withIndent('  ');
+      return encoder.convert(result);
+    }
+    if (result is Map) {
+      const encoder = JsonEncoder.withIndent('  ');
+      return encoder.convert(result);
+    }
+    return '$result';
+  }
+}
+
+enum _Kind { input, result, error, info }
+
+class _OutputLine {
+  const _OutputLine(this.text, this.kind);
+  final String text;
+  final _Kind kind;
+}
+
+class _DfCommand {
+  const _DfCommand({required this.help, required this.execute});
+  final String help;
+  final Future<String> Function(String rawArgs) execute;
+}
diff --git a/lib/features/settings/settings_screen.dart b/lib/features/settings/settings_screen.dart
index a3db7e4..e156273 100644
--- a/lib/features/settings/settings_screen.dart
+++ b/lib/features/settings/settings_screen.dart
@@ -92,7 +92,7 @@ class SettingsScreen extends ConsumerWidget {
         const _LogViewerTile(),
         const _TelemetryTile(),
         const Divider(),
-        // --- TEMPORARY: Debug agent screen — remove after F1 validation ---
+        // --- TEMPORARY: Debug screens — remove after validation ---
         ListTile(
           leading: const Icon(Icons.bug_report),
           title: const Text('Debug Agent Run'),
@@ -100,6 +100,13 @@ class SettingsScreen extends ConsumerWidget {
           trailing: const Icon(Icons.chevron_right),
           onTap: () => context.go('/debug/agent'),
         ),
+        ListTile(
+          leading: const Icon(Icons.table_chart),
+          title: const Text('Debug DataFrame REPL'),
+          subtitle: const Text('TEMPORARY — DataFrame validation'),
+          trailing: const Icon(Icons.chevron_right),
+          onTap: () => context.go('/debug/dataframe'),
+        ),
         // --- END TEMPORARY ---
         const Divider(),
         _AuthSection(authState: authState),
diff --git a/packages/soliplex_dataframe/analysis_options.yaml b/packages/soliplex_dataframe/analysis_options.yaml
new file mode 100644
index 0000000..ceb80c1
--- /dev/null
+++ b/packages/soliplex_dataframe/analysis_options.yaml
@@ -0,0 +1,12 @@
+include:
+  - package:very_good_analysis/analysis_options.10.0.0.yaml
+
+analyzer:
+  language:
+    strict-casts: true
+    strict-inference: true
+    strict-raw-types: true
+
+linter:
+  rules:
+    public_member_api_docs: false
diff --git a/packages/soliplex_dataframe/lib/soliplex_dataframe.dart b/packages/soliplex_dataframe/lib/soliplex_dataframe.dart
new file mode 100644
index 0000000..0b9946e
--- /dev/null
+++ b/packages/soliplex_dataframe/lib/soliplex_dataframe.dart
@@ -0,0 +1,5 @@
+/// Pure Dart DataFrame engine with handle-based registry.
+library;
+
+export 'src/data_frame.dart';
+export 'src/df_registry.dart';
diff --git a/packages/soliplex_dataframe/lib/src/data_frame.dart b/packages/soliplex_dataframe/lib/src/data_frame.dart
new file mode 100644
index 0000000..58490c4
--- /dev/null
+++ b/packages/soliplex_dataframe/lib/src/data_frame.dart
@@ -0,0 +1,379 @@
+import 'dart:convert';
+import 'dart:math';
+
+import 'package:meta/meta.dart';
+
+/// Simple in-memory DataFrame backed by `List<Map<String, dynamic>>`.
+///
+/// Pure Dart — no Flutter or platform imports.
+@immutable
+class DataFrame {
+  /// Creates a [DataFrame] from a list of row maps.
+  const DataFrame(this.rows);
+
+  /// The data rows.
+  final List<Map<String, dynamic>> rows;
+
+  /// Column names derived from the first row, or empty if no rows.
+  List<String> get columns =>
+      rows.isEmpty ? const [] : rows.first.keys.toList();
+
+  /// Number of rows.
+  int get length => rows.length;
+
+  /// Number of columns.
+  int get columnCount => columns.length;
+
+  /// Return first [n] rows as a new DataFrame.
+  DataFrame head([int n = 5]) => DataFrame(rows.take(n).toList());
+
+  /// Return last [n] rows as a new DataFrame.
+  DataFrame tail([int n = 5]) =>
+      DataFrame(rows.skip(max(0, rows.length - n)).toList());
+
+  /// Select specific columns.
+  DataFrame select(List<String> cols) => DataFrame([
+        for (final row in rows) {for (final c in cols) c: row[c]},
+      ]);
+
+  /// Filter rows where [column] [op] [value].
+  DataFrame filter(String column, String op, Object? value) {
+    bool test(Object? cell) => switch (op) {
+          '==' => cell == value,
+          '!=' => cell != value,
+          '>' => _cmp(cell, value) > 0,
+          '>=' => _cmp(cell, value) >= 0,
+          '<' => _cmp(cell, value) < 0,
+          '<=' => _cmp(cell, value) <= 0,
+          'contains' => cell.toString().contains(value.toString()),
+          _ => throw ArgumentError('Unknown op: $op'),
+        };
+    return DataFrame(
+      rows.where((r) => test(r[column])).toList(),
+    );
+  }
+
+  /// Sort by [column].
+  DataFrame sort(String column, {bool ascending = true}) {
+    final sorted = List<Map<String, dynamic>>.of(rows)
+      ..sort((a, b) {
+        final cmp = _cmp(a[column], b[column]);
+        return ascending ? cmp : -cmp;
+      });
+    return DataFrame(sorted);
+  }
+
+  /// Group by [groupCols] and aggregate with [aggMap].
+  ///
+  /// [aggMap] maps column names to aggregation functions:
+  /// `"sum"`, `"mean"`, `"min"`, `"max"`, `"count"`.
+  DataFrame groupAgg(
+    List<String> groupCols,
+    Map<String, String> aggMap,
+  ) {
+    final groups = <String, List<Map<String, dynamic>>>{};
+    for (final row in rows) {
+      final key = groupCols.map((c) => '${row[c]}').join('|');
+      (groups[key] ??= []).add(row);
+    }
+
+    final result = <Map<String, dynamic>>[];
+    for (final entry in groups.entries) {
+      final groupRows = entry.value;
+      final out = <String, dynamic>{};
+      for (final c in groupCols) {
+        out[c] = groupRows.first[c];
+      }
+      for (final MapEntry(key: col, value: fn) in aggMap.entries) {
+        final vals = groupRows.map((r) => r[col]).whereType<num>().toList();
+        out[col] = switch (fn) {
+          'sum' => vals.fold<num>(0, (a, b) => a + b),
+          'mean' =>
+            vals.isEmpty ? 0 : vals.fold<num>(0, (a, b) => a + b) / vals.length,
+          'min' => vals.isEmpty ? null : vals.reduce(min),
+          'max' => vals.isEmpty ? null : vals.reduce(max),
+          'count' => groupRows.length,
+          _ => throw ArgumentError('Unknown agg: $fn'),
+        };
+      }
+      result.add(out);
+    }
+    return DataFrame(result);
+  }
+
+  /// Add a column with the given values.
+  DataFrame addColumn(String name, List<Object?> values) {
+    final out = <Map<String, dynamic>>[];
+    for (var i = 0; i < rows.length; i++) {
+      out.add({
+        ...rows[i],
+        name: i < values.length ? values[i] : null,
+      });
+    }
+    return DataFrame(out);
+  }
+
+  /// Drop columns.
+  DataFrame drop(List<String> cols) => DataFrame([
+        for (final row in rows)
+          {
+            for (final e in row.entries)
+              if (!cols.contains(e.key)) e.key: e.value,
+          },
+      ]);
+
+  /// Rename columns.
+  DataFrame rename(Map<String, String> mapping) => DataFrame([
+        for (final row in rows)
+          {
+            for (final e in row.entries) (mapping[e.key] ?? e.key): e.value,
+          },
+      ]);
+
+  /// Merge with another DataFrame on [onCols] column(s).
+  DataFrame merge(
+    DataFrame other,
+    List<String> onCols, {
+    String how = 'inner',
+  }) {
+    final result = <Map<String, dynamic>>[];
+    for (final left in rows) {
+      for (final right in other.rows) {
+        final match = onCols.every((c) => left[c] == right[c]);
+        if (match) {
+          result.add({...left, ...right});
+        }
+      }
+    }
+    if (how == 'left') {
+      for (final left in rows) {
+        final hasMatch = result.any(
+          (r) => onCols.every((c) => r[c] == left[c]),
+        );
+        if (!hasMatch) result.add({...left});
+      }
+    }
+    return DataFrame(result);
+  }
+
+  /// Concatenate multiple DataFrames.
+  DataFrame concat(List<DataFrame> others) {
+    final all = [...rows];
+    for (final df in others) {
+      all.addAll(df.rows);
+    }
+    return DataFrame(all);
+  }
+
+  /// Fill null values.
+  DataFrame fillna(Object? value) => DataFrame([
+        for (final row in rows)
+          {
+            for (final e in row.entries) e.key: e.value ?? value,
+          },
+      ]);
+
+  /// Drop rows with any null values.
+  DataFrame dropna() => DataFrame(
+        rows.where((r) => r.values.every((v) => v != null)).toList(),
+      );
+
+  /// Transpose.
+  DataFrame transpose() {
+    if (rows.isEmpty) return const DataFrame([]);
+    final cols = columns;
+    final result = <Map<String, dynamic>>[];
+    for (final col in cols) {
+      final row = <String, dynamic>{'column': col};
+      for (var i = 0; i < rows.length; i++) {
+        row['row_$i'] = rows[i][col];
+      }
+      result.add(row);
+    }
+    return DataFrame(result);
+  }
+
+  /// Random sample of [n] rows.
+  DataFrame sample(int n) {
+    final rng = Random();
+    final indices = List.generate(rows.length, (i) => i)..shuffle(rng);
+    return DataFrame(
+      indices.take(min(n, rows.length)).map((i) => rows[i]).toList(),
+    );
+  }
+
+  /// Largest [n] by [column].
+  DataFrame nlargest(int n, String column) =>
+      sort(column, ascending: false).head(n);
+
+  /// Smallest [n] by [column].
+  DataFrame nsmallest(int n, String column) => sort(column).head(n);
+
+  /// Values for a single column.
+  List<Object?> columnValues(String column) =>
+      rows.map((r) => r[column]).toList();
+
+  /// Unique values in a column.
+  List<Object?> unique(String column) => columnValues(column).toSet().toList();
+
+  /// Value counts for a column.
+  Map<String, int> valueCounts(String column) {
+    final counts = <String, int>{};
+    for (final row in rows) {
+      final key = '${row[column]}';
+      counts[key] = (counts[key] ?? 0) + 1;
+    }
+    return counts;
+  }
+
+  // -- Aggregation helpers ---------------------------------------------------
+
+  List<num> _numericValues(String column) =>
+      rows.map((r) => r[column]).whereType<num>().toList();
+
+  /// Mean of a column, or all numeric columns if [column] is null.
+  Object? computeMean([String? column]) {
+    if (column != null) {
+      final vals = _numericValues(column);
+      return vals.isEmpty
+          ? null
+          : vals.fold<num>(0, (a, b) => a + b) / vals.length;
+    }
+    return {
+      for (final c in columns)
+        if (_numericValues(c).isNotEmpty) c: computeMean(c),
+    };
+  }
+
+  /// Sum of a column, or all numeric columns if [column] is null.
+  Object? computeSum([String? column]) {
+    if (column != null) {
+      return _numericValues(column).fold<num>(0, (a, b) => a + b);
+    }
+    return {
+      for (final c in columns)
+        if (_numericValues(c).isNotEmpty) c: computeSum(c),
+    };
+  }
+
+  /// Min of a column, or all numeric columns if [column] is null.
+  Object? computeMin([String? column]) {
+    if (column != null) {
+      final vals = _numericValues(column);
+      return vals.isEmpty ? null : vals.reduce(min);
+    }
+    return {
+      for (final c in columns)
+        if (_numericValues(c).isNotEmpty) c: computeMin(c),
+    };
+  }
+
+  /// Max of a column, or all numeric columns if [column] is null.
+  Object? computeMax([String? column]) {
+    if (column != null) {
+      final vals = _numericValues(column);
+      return vals.isEmpty ? null : vals.reduce(max);
+    }
+    return {
+      for (final c in columns)
+        if (_numericValues(c).isNotEmpty) c: computeMax(c),
+    };
+  }
+
+  /// Standard deviation of a column, or all numeric columns.
+  Object? computeStd([String? column]) {
+    if (column != null) {
+      final vals = _numericValues(column);
+      if (vals.length < 2) return null;
+      final mean = vals.fold<num>(0, (a, b) => a + b) / vals.length;
+      final variance = vals
+              .map((v) => (v - mean) * (v - mean))
+              .fold<num>(0, (a, b) => a + b) /
+          (vals.length - 1);
+      return sqrt(variance);
+    }
+    return {
+      for (final c in columns)
+        if (_numericValues(c).isNotEmpty) c: computeStd(c),
+    };
+  }
+
+  /// Describe: count, mean, std, min, max for each numeric column.
+  Map<String, Map<String, num?>> describe() {
+    final result = <String, Map<String, num?>>{};
+    for (final col in columns) {
+      final vals = _numericValues(col);
+      if (vals.isEmpty) continue;
+      final n = vals.length;
+      final mean = vals.fold<num>(0, (a, b) => a + b) / n;
+      final stdVal = n < 2
+          ? null
+          : sqrt(
+              vals
+                      .map((v) => (v - mean) * (v - mean))
+                      .fold<num>(0, (a, b) => a + b) /
+                  (n - 1),
+            );
+      result[col] = {
+        'count': n,
+        'mean': mean,
+        'std': stdVal,
+        'min': vals.reduce(min),
+        'max': vals.reduce(max),
+      };
+    }
+    return result;
+  }
+
+  /// Correlation matrix for numeric columns.
+  DataFrame corr() {
+    final numCols = columns.where((c) => _numericValues(c).isNotEmpty).toList();
+    final result = <Map<String, dynamic>>[];
+    for (final c1 in numCols) {
+      final row = <String, dynamic>{'column': c1};
+      final v1 = _numericValues(c1);
+      final m1 = v1.fold<num>(0, (a, b) => a + b) / v1.length;
+      for (final c2 in numCols) {
+        final v2 = _numericValues(c2);
+        final m2 = v2.fold<num>(0, (a, b) => a + b) / v2.length;
+        final n = min(v1.length, v2.length);
+        var cov = 0.0;
+        var s1 = 0.0;
+        var s2 = 0.0;
+        for (var i = 0; i < n; i++) {
+          cov += (v1[i] - m1) * (v2[i] - m2);
+          s1 += (v1[i] - m1) * (v1[i] - m1);
+          s2 += (v2[i] - m2) * (v2[i] - m2);
+        }
+        final denom = sqrt(s1) * sqrt(s2);
+        row[c2] = denom == 0 ? 0.0 : cov / denom;
+      }
+      result.add(row);
+    }
+    return DataFrame(result);
+  }
+
+  /// Export to CSV string.
+  String toCsv() {
+    if (rows.isEmpty) return '';
+    final cols = columns;
+    final buf = StringBuffer(cols.join(','));
+    for (final row in rows) {
+      buf
+        ..write('\n')
+        ..write(cols.map((c) => row[c] ?? '').join(','));
+    }
+    return buf.toString();
+  }
+
+  /// Export to JSON string.
+  String toJson() => jsonEncode(rows);
+
+  static int _cmp(Object? a, Object? b) {
+    if (a == null && b == null) return 0;
+    if (a == null) return -1;
+    if (b == null) return 1;
+    if (a is num && b is num) return a.compareTo(b);
+    return a.toString().compareTo(b.toString());
+  }
+}
diff --git a/packages/soliplex_dataframe/lib/src/df_registry.dart b/packages/soliplex_dataframe/lib/src/df_registry.dart
new file mode 100644
index 0000000..7f07c7b
--- /dev/null
+++ b/packages/soliplex_dataframe/lib/src/df_registry.dart
@@ -0,0 +1,155 @@
+import 'dart:convert';
+
+import 'package:soliplex_dataframe/src/data_frame.dart';
+
+/// Handle-based DataFrame storage.
+///
+/// Python receives integer handle IDs and passes them back to subsequent
+/// calls. Each Monty thread gets its own [DfRegistry] so DataFrames are
+/// isolated per conversation.
+class DfRegistry {
+  int _nextId = 1;
+  final _store = <int, DataFrame>{};
+
+  /// Register a [DataFrame] and return its handle ID.
+  int register(DataFrame df) {
+    final id = _nextId++;
+    _store[id] = df;
+    return id;
+  }
+
+  /// Get a [DataFrame] by handle ID.
+  ///
+  /// Throws [ArgumentError] if no DataFrame with [id] exists.
+  DataFrame get(int id) {
+    final df = _store[id];
+    if (df == null) {
+      throw ArgumentError('No DataFrame with handle $id');
+    }
+    return df;
+  }
+
+  /// Dispose a single handle.
+  void dispose(int id) => _store.remove(id);
+
+  /// Dispose all handles and reset IDs.
+  void disposeAll() {
+    _store.clear();
+    _nextId = 1;
+  }
+
+  /// Create a [DataFrame] from rows.
+  ///
+  /// If [data] is a list of maps, use directly.
+  /// If [data] is a list of lists with [columns], convert to maps.
+  ///
+  /// Handles Monty's serialization where maps may have non-String keys
+  /// and values may need type coercion.
+  int create(Object? data, [List<String>? columns]) {
+    if (data is List && data.isNotEmpty) {
+      if (data.first is Map) {
+        final rows = <Map<String, dynamic>>[];
+        for (final item in data) {
+          final src = item! as Map<Object?, Object?>;
+          final row = <String, dynamic>{};
+          for (final entry in src.entries) {
+            row[entry.key.toString()] = _coerceValue(entry.value);
+          }
+          rows.add(row);
+        }
+        return register(DataFrame(rows));
+      }
+      if (data.first is List && columns != null) {
+        final rows = <Map<String, dynamic>>[];
+        for (final item in data) {
+          final srcRow = item! as List<Object?>;
+          final map = <String, dynamic>{};
+          for (var i = 0; i < columns.length && i < srcRow.length; i++) {
+            map[columns[i]] = _coerceValue(srcRow[i]);
+          }
+          rows.add(map);
+        }
+        return register(DataFrame(rows));
+      }
+    }
+    throw ArgumentError(
+      'df_create expects a list of maps or '
+      'a list of lists with column names. '
+      'Got: ${data.runtimeType}',
+    );
+  }
+
+  /// Coerce a value from Monty into a clean Dart type.
+  static Object? _coerceValue(Object? v) {
+    if (v == null) return null;
+    if (v is num) return v;
+    if (v is bool) return v;
+    if (v is String) {
+      final asNum = num.tryParse(v);
+      if (asNum != null) return asNum;
+      return v;
+    }
+    if (v is List) return v.map(_coerceValue).toList();
+    if (v is Map) {
+      return <String, dynamic>{
+        for (final e in v.entries) e.key.toString(): _coerceValue(e.value),
+      };
+    }
+    return v;
+  }
+
+  /// Parse CSV string into a [DataFrame].
+  int fromCsv(String csv, [String delimiter = ',']) {
+    final lines = const LineSplitter().convert(csv.trim());
+    if (lines.isEmpty) return register(const DataFrame([]));
+    final headers = lines.first.split(delimiter).map((s) => s.trim()).toList();
+    final rows = <Map<String, dynamic>>[];
+    for (final line in lines.skip(1)) {
+      if (line.trim().isEmpty) continue;
+      final values = line.split(delimiter);
+      final row = <String, dynamic>{};
+      for (var i = 0; i < headers.length; i++) {
+        final raw = i < values.length ? values[i].trim() : '';
+        row[headers[i]] = _parseValue(raw);
+      }
+      rows.add(row);
+    }
+    return register(DataFrame(rows));
+  }
+
+  /// Parse JSON string into a [DataFrame].
+  int fromJson(String jsonStr) {
+    final data = jsonDecode(jsonStr);
+    if (data is List) {
+      final rows = <Map<String, dynamic>>[];
+      for (final item in data) {
+        final src = item as Map<Object?, Object?>;
+        final row = <String, dynamic>{};
+        for (final entry in src.entries) {
+          row[entry.key.toString()] = _coerceValue(entry.value);
+        }
+        rows.add(row);
+      }
+      return register(DataFrame(rows));
+    }
+    throw ArgumentError('df_from_json expects a JSON array of objects');
+  }
+
+  /// Try to parse a string to int, double, bool, or leave as String.
+  static Object? _parseValue(String raw) {
+    if (raw.isEmpty) return null;
+    final asInt = int.tryParse(raw);
+    if (asInt != null) return asInt;
+    final asDouble = double.tryParse(raw);
+    if (asDouble != null) return asDouble;
+    if (raw == 'true') return true;
+    if (raw == 'false') return false;
+    if (raw == 'null' || raw == 'None') return null;
+    // Strip surrounding quotes if present
+    if ((raw.startsWith('"') && raw.endsWith('"')) ||
+        (raw.startsWith("'") && raw.endsWith("'"))) {
+      return raw.substring(1, raw.length - 1);
+    }
+    return raw;
+  }
+}
diff --git a/packages/soliplex_dataframe/pubspec.yaml b/packages/soliplex_dataframe/pubspec.yaml
new file mode 100644
index 0000000..0359bf1
--- /dev/null
+++ b/packages/soliplex_dataframe/pubspec.yaml
@@ -0,0 +1,14 @@
+name: soliplex_dataframe
+description: Pure Dart DataFrame engine with handle-based registry.
+version: 0.1.0
+publish_to: none
+
+environment:
+  sdk: ^3.6.0
+
+dependencies:
+  meta: ^1.11.0
+
+dev_dependencies:
+  test: ^1.24.0
+  very_good_analysis: ^10.0.0
diff --git a/packages/soliplex_dataframe/test/src/data_frame_test.dart b/packages/soliplex_dataframe/test/src/data_frame_test.dart
new file mode 100644
index 0000000..3321514
--- /dev/null
+++ b/packages/soliplex_dataframe/test/src/data_frame_test.dart
@@ -0,0 +1,406 @@
+import 'dart:convert';
+
+import 'package:soliplex_dataframe/soliplex_dataframe.dart';
+import 'package:test/test.dart';
+
+void main() {
+  group('DataFrame', () {
+    late DataFrame df;
+
+    setUp(() {
+      df = const DataFrame([
+        {'name': 'Alice', 'age': 30, 'score': 90},
+        {'name': 'Bob', 'age': 25, 'score': 85},
+        {'name': 'Carol', 'age': 35, 'score': 92},
+        {'name': 'Dave', 'age': 28, 'score': 88},
+        {'name': 'Eve', 'age': 32, 'score': 95},
+      ]);
+    });
+
+    group('construction', () {
+      test('creates from rows', () {
+        expect(df.length, 5);
+        expect(df.columnCount, 3);
+      });
+
+      test('empty DataFrame', () {
+        const empty = DataFrame([]);
+        expect(empty.length, 0);
+        expect(empty.columns, isEmpty);
+        expect(empty.columnCount, 0);
+      });
+    });
+
+    group('properties', () {
+      test('columns returns first row keys', () {
+        expect(df.columns, ['name', 'age', 'score']);
+      });
+
+      test('length returns row count', () {
+        expect(df.length, 5);
+      });
+
+      test('columnCount returns column count', () {
+        expect(df.columnCount, 3);
+      });
+    });
+
+    group('head/tail', () {
+      test('head returns first 5 by default', () {
+        expect(df.head().length, 5);
+      });
+
+      test('head with custom n', () {
+        expect(df.head(2).length, 2);
+        expect(df.head(2).rows.first['name'], 'Alice');
+      });
+
+      test('tail returns last 5 by default', () {
+        expect(df.tail().length, 5);
+      });
+
+      test('tail with custom n', () {
+        final result = df.tail(2);
+        expect(result.length, 2);
+        expect(result.rows.first['name'], 'Dave');
+        expect(result.rows.last['name'], 'Eve');
+      });
+    });
+
+    group('select', () {
+      test('selects specific columns', () {
+        final result = df.select(['name', 'age']);
+        expect(result.columns, ['name', 'age']);
+        expect(result.rows.first.containsKey('score'), isFalse);
+      });
+    });
+
+    group('filter', () {
+      test('== operator', () {
+        final result = df.filter('name', '==', 'Alice');
+        expect(result.length, 1);
+        expect(result.rows.first['name'], 'Alice');
+      });
+
+      test('!= operator', () {
+        final result = df.filter('name', '!=', 'Alice');
+        expect(result.length, 4);
+      });
+
+      test('> operator', () {
+        final result = df.filter('age', '>', 30);
+        expect(result.length, 2);
+      });
+
+      test('>= operator', () {
+        final result = df.filter('age', '>=', 30);
+        expect(result.length, 3);
+      });
+
+      test('< operator', () {
+        final result = df.filter('age', '<', 30);
+        expect(result.length, 2);
+      });
+
+      test('<= operator', () {
+        final result = df.filter('age', '<=', 30);
+        expect(result.length, 3);
+      });
+
+      test('contains operator', () {
+        final result = df.filter('name', 'contains', 'a');
+        // Carol, Dave have 'a' in them (case-sensitive)
+        expect(result.length, 2);
+      });
+
+      test('throws on unknown operator', () {
+        expect(
+          () => df.filter('age', '~', 30),
+          throwsArgumentError,
+        );
+      });
+    });
+
+    group('sort', () {
+      test('ascending by default', () {
+        final result = df.sort('age');
+        expect(result.rows.first['name'], 'Bob');
+        expect(result.rows.last['name'], 'Carol');
+      });
+
+      test('descending', () {
+        final result = df.sort('age', ascending: false);
+        expect(result.rows.first['name'], 'Carol');
+        expect(result.rows.last['name'], 'Bob');
+      });
+    });
+
+    group('groupAgg', () {
+      test('sum aggregation', () {
+        const grouped = DataFrame([
+          {'dept': 'A', 'sales': 10},
+          {'dept': 'A', 'sales': 20},
+          {'dept': 'B', 'sales': 30},
+        ]);
+        final result = grouped.groupAgg(['dept'], {'sales': 'sum'});
+        expect(result.length, 2);
+        final deptA = result.rows.firstWhere((r) => r['dept'] == 'A');
+        expect(deptA['sales'], 30);
+      });
+
+      test('mean aggregation', () {
+        const grouped = DataFrame([
+          {'dept': 'A', 'sales': 10},
+          {'dept': 'A', 'sales': 20},
+        ]);
+        final result = grouped.groupAgg(['dept'], {'sales': 'mean'});
+        expect(result.rows.first['sales'], 15.0);
+      });
+
+      test('count aggregation', () {
+        const grouped = DataFrame([
+          {'dept': 'A', 'sales': 10},
+          {'dept': 'A', 'sales': 20},
+          {'dept': 'B', 'sales': 30},
+        ]);
+        final result = grouped.groupAgg(['dept'], {'sales': 'count'});
+        final deptA = result.rows.firstWhere((r) => r['dept'] == 'A');
+        expect(deptA['sales'], 2);
+      });
+    });
+
+    group('addColumn', () {
+      test('adds column with values', () {
+        final result = df.addColumn('grade', ['A', 'B', 'A', 'B', 'A']);
+        expect(result.columns, contains('grade'));
+        expect(result.rows.first['grade'], 'A');
+      });
+    });
+
+    group('drop', () {
+      test('drops specified columns', () {
+        final result = df.drop(['score']);
+        expect(result.columns, ['name', 'age']);
+      });
+    });
+
+    group('rename', () {
+      test('renames columns', () {
+        final result = df.rename({'name': 'full_name'});
+        expect(result.columns, contains('full_name'));
+        expect(result.columns, isNot(contains('name')));
+      });
+    });
+
+    group('merge', () {
+      test('inner merge', () {
+        const left = DataFrame([
+          {'id': 1, 'name': 'Alice'},
+          {'id': 2, 'name': 'Bob'},
+          {'id': 3, 'name': 'Carol'},
+        ]);
+        const right = DataFrame([
+          {'id': 1, 'dept': 'Eng'},
+          {'id': 2, 'dept': 'Sales'},
+        ]);
+        final result = left.merge(right, ['id']);
+        expect(result.length, 2);
+        expect(result.rows.first['name'], 'Alice');
+        expect(result.rows.first['dept'], 'Eng');
+      });
+    });
+
+    group('concat', () {
+      test('concatenates DataFrames', () {
+        const df1 = DataFrame([
+          {'x': 1},
+        ]);
+        const df2 = DataFrame([
+          {'x': 2},
+        ]);
+        final result = df1.concat([df2]);
+        expect(result.length, 2);
+      });
+    });
+
+    group('fillna', () {
+      test('fills null values', () {
+        const withNulls = DataFrame([
+          {'a': 1, 'b': null},
+          {'a': null, 'b': 2},
+        ]);
+        final result = withNulls.fillna(0);
+        expect(result.rows[0]['b'], 0);
+        expect(result.rows[1]['a'], 0);
+      });
+    });
+
+    group('dropna', () {
+      test('drops rows with nulls', () {
+        const withNulls = DataFrame([
+          {'a': 1, 'b': 2},
+          {'a': null, 'b': 2},
+          {'a': 3, 'b': 4},
+        ]);
+        final result = withNulls.dropna();
+        expect(result.length, 2);
+      });
+    });
+
+    group('transpose', () {
+      test('transposes rows and columns', () {
+        const small = DataFrame([
+          {'a': 1, 'b': 2},
+          {'a': 3, 'b': 4},
+        ]);
+        final result = small.transpose();
+        expect(result.length, 2);
+        expect(result.rows.first['column'], 'a');
+        expect(result.rows.first['row_0'], 1);
+        expect(result.rows.first['row_1'], 3);
+      });
+
+      test('empty DataFrame transposes to empty', () {
+        const empty = DataFrame([]);
+        expect(empty.transpose().length, 0);
+      });
+    });
+
+    group('sample', () {
+      test('returns n rows', () {
+        final result = df.sample(3);
+        expect(result.length, 3);
+      });
+
+      test('clamps to available rows', () {
+        final result = df.sample(100);
+        expect(result.length, 5);
+      });
+    });
+
+    group('nlargest', () {
+      test('returns largest n by column', () {
+        final result = df.nlargest(2, 'age');
+        expect(result.length, 2);
+        expect(result.rows.first['name'], 'Carol'); // age 35
+        expect(result.rows.last['name'], 'Eve'); // age 32
+      });
+    });
+
+    group('nsmallest', () {
+      test('returns smallest n by column', () {
+        final result = df.nsmallest(2, 'age');
+        expect(result.length, 2);
+        expect(result.rows.first['name'], 'Bob'); // age 25
+        expect(result.rows.last['name'], 'Dave'); // age 28
+      });
+    });
+
+    group('aggregation', () {
+      test('computeMean for single column', () {
+        expect(df.computeMean('age'), 30.0);
+      });
+
+      test('computeMean for all columns', () {
+        final result = df.computeMean()! as Map<String, dynamic>;
+        expect(result.containsKey('age'), isTrue);
+        expect(result.containsKey('score'), isTrue);
+      });
+
+      test('computeSum for single column', () {
+        expect(df.computeSum('age'), 150);
+      });
+
+      test('computeMin for single column', () {
+        expect(df.computeMin('age'), 25);
+      });
+
+      test('computeMax for single column', () {
+        expect(df.computeMax('age'), 35);
+      });
+
+      test('computeStd for single column', () {
+        final std = df.computeStd('age')! as double;
+        expect(std, closeTo(3.81, 0.01));
+      });
+
+      test('computeStd returns null for < 2 values', () {
+        const single = DataFrame([
+          {'x': 5},
+        ]);
+        expect(single.computeStd('x'), isNull);
+      });
+    });
+
+    group('describe', () {
+      test('returns stats for numeric columns', () {
+        final desc = df.describe();
+        expect(desc.containsKey('age'), isTrue);
+        expect(desc['age']!['count'], 5);
+        expect(desc['age']!['mean'], 30.0);
+        expect(desc['age']!['min'], 25);
+        expect(desc['age']!['max'], 35);
+      });
+    });
+
+    group('corr', () {
+      test('returns correlation matrix', () {
+        final result = df.corr();
+        expect(result.length, 2); // age, score
+        final ageRow = result.rows.firstWhere((r) => r['column'] == 'age');
+        expect(ageRow['age'] as double, closeTo(1.0, 0.001));
+      });
+    });
+
+    group('export', () {
+      test('toCsv', () {
+        final csv = df.toCsv();
+        expect(csv, startsWith('name,age,score'));
+        expect(csv, contains('Alice'));
+      });
+
+      test('toCsv empty', () {
+        expect(const DataFrame([]).toCsv(), '');
+      });
+
+      test('toJson', () {
+        final json = df.toJson();
+        final decoded = jsonDecode(json) as List<Object?>;
+        expect(decoded.length, 5);
+      });
+    });
+
+    group('columnValues', () {
+      test('returns values for column', () {
+        expect(
+          df.columnValues('name'),
+          ['Alice', 'Bob', 'Carol', 'Dave', 'Eve'],
+        );
+      });
+    });
+
+    group('unique', () {
+      test('returns unique values', () {
+        const dup = DataFrame([
+          {'x': 'a'},
+          {'x': 'b'},
+          {'x': 'a'},
+        ]);
+        expect(dup.unique('x'), hasLength(2));
+      });
+    });
+
+    group('valueCounts', () {
+      test('counts occurrences', () {
+        const dup = DataFrame([
+          {'x': 'a'},
+          {'x': 'b'},
+          {'x': 'a'},
+        ]);
+        final counts = dup.valueCounts('x');
+        expect(counts['a'], 2);
+        expect(counts['b'], 1);
+      });
+    });
+  });
+}
diff --git a/packages/soliplex_dataframe/test/src/df_registry_test.dart b/packages/soliplex_dataframe/test/src/df_registry_test.dart
new file mode 100644
index 0000000..80b42bc
--- /dev/null
+++ b/packages/soliplex_dataframe/test/src/df_registry_test.dart
@@ -0,0 +1,175 @@
+import 'package:soliplex_dataframe/soliplex_dataframe.dart';
+import 'package:test/test.dart';
+
+void main() {
+  group('DfRegistry', () {
+    late DfRegistry registry;
+
+    setUp(() {
+      registry = DfRegistry();
+    });
+
+    group('register / get', () {
+      test('registers and retrieves a DataFrame', () {
+        const df = DataFrame([
+          {'a': 1},
+        ]);
+        final handle = registry.register(df);
+        expect(handle, isPositive);
+        expect(registry.get(handle).rows, df.rows);
+      });
+
+      test('throws on missing handle', () {
+        expect(() => registry.get(999), throwsArgumentError);
+      });
+    });
+
+    group('dispose', () {
+      test('removes a handle', () {
+        final handle = registry.register(
+          const DataFrame([
+            {'a': 1},
+          ]),
+        );
+        registry.dispose(handle);
+        expect(() => registry.get(handle), throwsArgumentError);
+      });
+
+      test('disposeAll clears all handles', () {
+        final h1 = registry.register(
+          const DataFrame([
+            {'a': 1},
+          ]),
+        );
+        final h2 = registry.register(
+          const DataFrame([
+            {'b': 2},
+          ]),
+        );
+        registry.disposeAll();
+        expect(() => registry.get(h1), throwsArgumentError);
+        expect(() => registry.get(h2), throwsArgumentError);
+      });
+    });
+
+    group('create', () {
+      test('from list of maps', () {
+        final handle = registry.create([
+          {'name': 'Alice', 'age': 30},
+          {'name': 'Bob', 'age': 25},
+        ]);
+        final df = registry.get(handle);
+        expect(df.length, 2);
+        expect(df.columns, ['name', 'age']);
+      });
+
+      test('from list of lists with columns', () {
+        final handle = registry.create(
+          [
+            ['Alice', 30],
+            ['Bob', 25],
+          ],
+          ['name', 'age'],
+        );
+        final df = registry.get(handle);
+        expect(df.length, 2);
+        expect(df.rows.first['name'], 'Alice');
+        expect(df.rows.first['age'], 30);
+      });
+
+      test('throws on invalid data', () {
+        expect(() => registry.create('invalid'), throwsArgumentError);
+        expect(() => registry.create([]), throwsArgumentError);
+      });
+
+      test('coerces numeric strings in map values', () {
+        final handle = registry.create([
+          {'value': '42'},
+        ]);
+        final df = registry.get(handle);
+        expect(df.rows.first['value'], 42);
+      });
+
+      test('coerces non-string map keys to string', () {
+        final handle = registry.create([
+          {1: 'one', 2: 'two'},
+        ]);
+        final df = registry.get(handle);
+        expect(df.columns, ['1', '2']);
+      });
+    });
+
+    group('fromCsv', () {
+      test('parses headers and rows', () {
+        const csv = 'name,age,score\nAlice,30,90\nBob,25,85';
+        final handle = registry.fromCsv(csv);
+        final df = registry.get(handle);
+        expect(df.length, 2);
+        expect(df.columns, ['name', 'age', 'score']);
+        expect(df.rows.first['name'], 'Alice');
+        expect(df.rows.first['age'], 30);
+      });
+
+      test('handles empty CSV', () {
+        final handle = registry.fromCsv('');
+        expect(registry.get(handle).length, 0);
+      });
+
+      test('parses booleans', () {
+        const csv = 'flag\ntrue\nfalse';
+        final handle = registry.fromCsv(csv);
+        final df = registry.get(handle);
+        expect(df.rows[0]['flag'], true);
+        expect(df.rows[1]['flag'], false);
+      });
+
+      test('parses null/None as null', () {
+        const csv = 'x\nnull\nNone';
+        final handle = registry.fromCsv(csv);
+        final df = registry.get(handle);
+        expect(df.rows[0]['x'], isNull);
+        expect(df.rows[1]['x'], isNull);
+      });
+    });
+
+    group('fromJson', () {
+      test('parses JSON array of objects', () {
+        const json = '[{"a": 1, "b": 2}, {"a": 3, "b": 4}]';
+        final handle = registry.fromJson(json);
+        final df = registry.get(handle);
+        expect(df.length, 2);
+        expect(df.rows.first['a'], 1);
+      });
+
+      test('throws on non-array JSON', () {
+        expect(() => registry.fromJson('{"a": 1}'), throwsArgumentError);
+      });
+    });
+
+    group('coercion', () {
+      test('coerces nested structures via create', () {
+        final handle = registry.create([
+          {
+            'nested': {'key': '42'},
+          },
+        ]);
+        final df = registry.get(handle);
+        final nested = df.rows.first['nested'] as Map<String, dynamic>;
+        expect(nested['key'], 42);
+      });
+
+      test('coerces list values via create', () {
+        final handle = registry.create([
+          {
+            'tags': ['1', '2', 'hello'],
+          },
+        ]);
+        final df = registry.get(handle);
+        final tags = df.rows.first['tags'] as List<Object?>;
+        expect(tags[0], 1);
+        expect(tags[1], 2);
+        expect(tags[2], 'hello');
+      });
+    });
+  });
+}
diff --git a/packages/soliplex_interpreter_monty/lib/src/bridge/host_param.dart b/packages/soliplex_interpreter_monty/lib/src/bridge/host_param.dart
index a6d19f6..15030b2 100644
--- a/packages/soliplex_interpreter_monty/lib/src/bridge/host_param.dart
+++ b/packages/soliplex_interpreter_monty/lib/src/bridge/host_param.dart
@@ -50,6 +50,7 @@ class HostParam {
       HostParamType.boolean => _expectType<bool>(value),
       HostParamType.list => _expectType<List<Object?>>(value),
       HostParamType.map => _expectType<Map<String, Object?>>(value),
+      HostParamType.any => value,
     };
   }
 
diff --git a/packages/soliplex_interpreter_monty/lib/src/bridge/host_param_type.dart b/packages/soliplex_interpreter_monty/lib/src/bridge/host_param_type.dart
index 51cb74d..3e75019 100644
--- a/packages/soliplex_interpreter_monty/lib/src/bridge/host_param_type.dart
+++ b/packages/soliplex_interpreter_monty/lib/src/bridge/host_param_type.dart
@@ -16,7 +16,12 @@ enum HostParamType {
   list,
 
   /// Map/dict parameter. Monty Python `dict`.
-  map;
+  map,
+
+  /// Any type — passes through validation without type checking.
+  ///
+  /// Used for parameters like filter values that accept str, int, float, etc.
+  any;
 
   /// JSON Schema type name for ag-ui Tool export.
   String get jsonSchemaType => switch (this) {
@@ -26,5 +31,6 @@ enum HostParamType {
         boolean => 'boolean',
         list => 'array',
         map => 'object',
+        any => 'string',
       };
 }
diff --git a/packages/soliplex_scripting/lib/soliplex_scripting.dart b/packages/soliplex_scripting/lib/soliplex_scripting.dart
index 73fcadd..fc6a593 100644
--- a/packages/soliplex_scripting/lib/soliplex_scripting.dart
+++ b/packages/soliplex_scripting/lib/soliplex_scripting.dart
@@ -5,6 +5,7 @@ export 'package:soliplex_agent/soliplex_agent.dart' show ThreadKey;
 
 export 'src/ag_ui_bridge_adapter.dart';
 export 'src/bridge_cache.dart';
+export 'src/df_functions.dart';
 export 'src/host_function_wiring.dart';
 export 'src/host_schema_ag_ui.dart';
 export 'src/monty_tool_executor.dart';
diff --git a/packages/soliplex_scripting/lib/src/bridge_cache.dart b/packages/soliplex_scripting/lib/src/bridge_cache.dart
index ad5f20d..865d07d 100644
--- a/packages/soliplex_scripting/lib/src/bridge_cache.dart
+++ b/packages/soliplex_scripting/lib/src/bridge_cache.dart
@@ -1,4 +1,5 @@
 import 'package:soliplex_agent/soliplex_agent.dart' show ThreadKey;
+import 'package:soliplex_dataframe/soliplex_dataframe.dart';
 import 'package:soliplex_interpreter_monty/soliplex_interpreter_monty.dart';
 
 /// Manages a pool of [MontyBridge] instances keyed by [ThreadKey].
@@ -7,6 +8,8 @@ import 'package:soliplex_interpreter_monty/soliplex_interpreter_monty.dart';
 /// the same thread. When the concurrency limit is reached, the
 /// least-recently-used idle bridge is evicted and disposed.
 ///
+/// Each bridge has an associated [DfRegistry] that is cleaned up on evict.
+///
 /// The WASM guard throws [StateError] when all bridges are executing
 /// and the limit is reached — preventing deadlock on single-threaded
 /// platforms.
@@ -25,6 +28,9 @@ class BridgeCache {
   /// Bridges keyed by thread. Insertion order tracks LRU (oldest first).
   final _bridges = <ThreadKey, MontyBridge>{};
 
+  /// DfRegistry per thread — cleaned up when bridge is evicted.
+  final _registries = <ThreadKey, DfRegistry>{};
+
   /// Threads whose bridge is currently executing.
   final _executing = <ThreadKey>{};
 
@@ -37,6 +43,11 @@ class BridgeCache {
   /// Whether the bridge for [key] is currently executing.
   bool isExecuting(ThreadKey key) => _executing.contains(key);
 
+  /// Returns the [DfRegistry] associated with [key].
+  ///
+  /// Creates one if it doesn't exist yet.
+  DfRegistry registryFor(ThreadKey key) => _registries[key] ??= DfRegistry();
+
   /// Returns the bridge for [key], creating one if needed.
   ///
   /// If the cache is at capacity, the least-recently-used idle bridge
@@ -78,17 +89,24 @@ class BridgeCache {
   }
 
   /// Removes and disposes the bridge for [key].
+  ///
+  /// Also disposes the associated [DfRegistry].
   void evict(ThreadKey key) {
     _executing.remove(key);
     _bridges.remove(key)?.dispose();
+    _registries.remove(key)?.disposeAll();
   }
 
-  /// Disposes all cached bridges and clears the cache.
+  /// Disposes all cached bridges and registries, then clears the cache.
   void disposeAll() {
     for (final bridge in _bridges.values) {
       bridge.dispose();
     }
+    for (final registry in _registries.values) {
+      registry.disposeAll();
+    }
     _bridges.clear();
+    _registries.clear();
     _executing.clear();
   }
 
diff --git a/packages/soliplex_scripting/lib/src/df_functions.dart b/packages/soliplex_scripting/lib/src/df_functions.dart
new file mode 100644
index 0000000..38cfef6
--- /dev/null
+++ b/packages/soliplex_scripting/lib/src/df_functions.dart
@@ -0,0 +1,720 @@
+// TEMPORARY: DataFrame host functions — decouple after validation.
+// Tracking: these will move to a dedicated wiring package once the
+// package structure settles.
+
+import 'package:soliplex_dataframe/soliplex_dataframe.dart';
+import 'package:soliplex_interpreter_monty/soliplex_interpreter_monty.dart';
+
+/// Builds all df_* host functions backed by [registry].
+///
+/// Each function has a [HostFunctionSchema] with typed parameters and a
+/// handler closure that delegates to [DfRegistry] / [DataFrame] methods.
+List<HostFunction> buildDfFunctions(DfRegistry registry) => [
+      // -- Create (3) --------------------------------------------------------
+
+      HostFunction(
+        schema: const HostFunctionSchema(
+          name: 'df_create',
+          description: 'Create a DataFrame from a list of row maps '
+              'or list of lists with column names.',
+          params: [
+            HostParam(
+              name: 'data',
+              type: HostParamType.list,
+              description: 'Row data',
+            ),
+            HostParam(
+              name: 'columns',
+              type: HostParamType.list,
+              isRequired: false,
+              description: 'Column names (for list-of-lists)',
+            ),
+          ],
+        ),
+        handler: (args) async => registry.create(
+          args['data'],
+          _castStringList(args['columns']),
+        ),
+      ),
+
+      HostFunction(
+        schema: const HostFunctionSchema(
+          name: 'df_from_csv',
+          description: 'Create a DataFrame from a CSV string.',
+          params: [
+            HostParam(
+              name: 'csv',
+              type: HostParamType.string,
+              description: 'CSV text',
+            ),
+            HostParam(
+              name: 'delimiter',
+              type: HostParamType.string,
+              isRequired: false,
+              defaultValue: ',',
+              description: 'Column delimiter',
+            ),
+          ],
+        ),
+        handler: (args) async => registry.fromCsv(
+          args['csv']! as String,
+          args['delimiter'] as String? ?? ',',
+        ),
+      ),
+
+      HostFunction(
+        schema: const HostFunctionSchema(
+          name: 'df_from_json',
+          description: 'Create a DataFrame from a JSON array of objects.',
+          params: [
+            HostParam(
+              name: 'json',
+              type: HostParamType.string,
+              description: 'JSON string',
+            ),
+          ],
+        ),
+        handler: (args) async => registry.fromJson(args['json']! as String),
+      ),
+
+      // -- Inspect (9) -------------------------------------------------------
+
+      HostFunction(
+        schema: const HostFunctionSchema(
+          name: 'df_shape',
+          description: 'Return [rows, columns] shape of a DataFrame.',
+          params: [_handleParam],
+        ),
+        handler: (args) async {
+          final df = registry.get(_handle(args));
+          return [df.length, df.columnCount];
+        },
+      ),
+
+      HostFunction(
+        schema: const HostFunctionSchema(
+          name: 'df_columns',
+          description: 'Return column names of a DataFrame.',
+          params: [_handleParam],
+        ),
+        handler: (args) async => registry.get(_handle(args)).columns,
+      ),
+
+      HostFunction(
+        schema: const HostFunctionSchema(
+          name: 'df_head',
+          description: 'Return first n rows (default 5).',
+          params: [
+            _handleParam,
+            HostParam(
+              name: 'n',
+              type: HostParamType.number,
+              isRequired: false,
+              defaultValue: 5,
+              description: 'Number of rows',
+            ),
+          ],
+        ),
+        handler: (args) async =>
+            registry.get(_handle(args)).head(_intOr(args['n'], 5)).rows,
+      ),
+
+      HostFunction(
+        schema: const HostFunctionSchema(
+          name: 'df_tail',
+          description: 'Return last n rows (default 5).',
+          params: [
+            _handleParam,
+            HostParam(
+              name: 'n',
+              type: HostParamType.number,
+              isRequired: false,
+              defaultValue: 5,
+              description: 'Number of rows',
+            ),
+          ],
+        ),
+        handler: (args) async =>
+            registry.get(_handle(args)).tail(_intOr(args['n'], 5)).rows,
+      ),
+
+      HostFunction(
+        schema: const HostFunctionSchema(
+          name: 'df_describe',
+          description: 'Return count, mean, std, min, max for numeric columns.',
+          params: [_handleParam],
+        ),
+        handler: (args) async => registry.get(_handle(args)).describe(),
+      ),
+
+      HostFunction(
+        schema: const HostFunctionSchema(
+          name: 'df_to_csv',
+          description: 'Export DataFrame to CSV string.',
+          params: [_handleParam],
+        ),
+        handler: (args) async => registry.get(_handle(args)).toCsv(),
+      ),
+
+      HostFunction(
+        schema: const HostFunctionSchema(
+          name: 'df_to_json',
+          description: 'Export DataFrame to JSON string.',
+          params: [_handleParam],
+        ),
+        handler: (args) async => registry.get(_handle(args)).toJson(),
+      ),
+
+      HostFunction(
+        schema: const HostFunctionSchema(
+          name: 'df_to_list',
+          description: 'Return all rows as list of maps.',
+          params: [_handleParam],
+        ),
+        handler: (args) async => registry.get(_handle(args)).rows,
+      ),
+
+      HostFunction(
+        schema: const HostFunctionSchema(
+          name: 'df_column_values',
+          description: 'Return all values for a single column.',
+          params: [
+            _handleParam,
+            HostParam(
+              name: 'column',
+              type: HostParamType.string,
+              description: 'Column name',
+            ),
+          ],
+        ),
+        handler: (args) async =>
+            registry.get(_handle(args)).columnValues(args['column']! as String),
+      ),
+
+      // -- Transform (15) ----------------------------------------------------
+
+      HostFunction(
+        schema: const HostFunctionSchema(
+          name: 'df_select',
+          description: 'Select specific columns, return new handle.',
+          params: [
+            _handleParam,
+            HostParam(
+              name: 'columns',
+              type: HostParamType.list,
+              description: 'Column names to select',
+            ),
+          ],
+        ),
+        handler: (args) async => registry.register(
+          registry.get(_handle(args)).select(_castStringList(args['columns'])!),
+        ),
+      ),
+
+      HostFunction(
+        schema: const HostFunctionSchema(
+          name: 'df_filter',
+          description: 'Filter rows where column op value, return new handle.',
+          params: [
+            _handleParam,
+            HostParam(
+              name: 'column',
+              type: HostParamType.string,
+              description: 'Column name',
+            ),
+            HostParam(
+              name: 'op',
+              type: HostParamType.string,
+              description:
+                  'Comparison operator (==, !=, >, >=, <, <=, contains)',
+            ),
+            HostParam(
+              name: 'value',
+              type: HostParamType.any,
+              isRequired: false,
+              description: 'Value to compare (string, number, or bool)',
+            ),
+          ],
+        ),
+        handler: (args) async => registry.register(
+          registry.get(_handle(args)).filter(
+                args['column']! as String,
+                args['op']! as String,
+                args['value'],
+              ),
+        ),
+      ),
+
+      HostFunction(
+        schema: const HostFunctionSchema(
+          name: 'df_sort',
+          description: 'Sort by column, return new handle.',
+          params: [
+            _handleParam,
+            HostParam(
+              name: 'column',
+              type: HostParamType.string,
+              description: 'Column to sort by',
+            ),
+            HostParam(
+              name: 'ascending',
+              type: HostParamType.boolean,
+              isRequired: false,
+              defaultValue: true,
+              description: 'Sort ascending (default true)',
+            ),
+          ],
+        ),
+        handler: (args) async => registry.register(
+          registry.get(_handle(args)).sort(
+                args['column']! as String,
+                ascending: args['ascending'] as bool? ?? true,
+              ),
+        ),
+      ),
+
+      HostFunction(
+        schema: const HostFunctionSchema(
+          name: 'df_group_agg',
+          description: 'Group by columns and aggregate, return new handle.',
+          params: [
+            _handleParam,
+            HostParam(
+              name: 'group_cols',
+              type: HostParamType.list,
+              description: 'Columns to group by',
+            ),
+            HostParam(
+              name: 'agg_map',
+              type: HostParamType.map,
+              description: 'Map of column to agg function '
+                  '(sum, mean, min, max, count)',
+            ),
+          ],
+        ),
+        handler: (args) async => registry.register(
+          registry.get(_handle(args)).groupAgg(
+                _castStringList(args['group_cols'])!,
+                Map<String, String>.from(
+                  args['agg_map']! as Map<String, Object?>,
+                ),
+              ),
+        ),
+      ),
+
+      HostFunction(
+        schema: const HostFunctionSchema(
+          name: 'df_add_column',
+          description: 'Add a column with values, return new handle.',
+          params: [
+            _handleParam,
+            HostParam(
+              name: 'name',
+              type: HostParamType.string,
+              description: 'New column name',
+            ),
+            HostParam(
+              name: 'values',
+              type: HostParamType.list,
+              description: 'Column values',
+            ),
+          ],
+        ),
+        handler: (args) async => registry.register(
+          registry.get(_handle(args)).addColumn(
+                args['name']! as String,
+                (args['values']! as List<Object?>).cast<Object?>(),
+              ),
+        ),
+      ),
+
+      HostFunction(
+        schema: const HostFunctionSchema(
+          name: 'df_drop',
+          description: 'Drop columns, return new handle.',
+          params: [
+            _handleParam,
+            HostParam(
+              name: 'columns',
+              type: HostParamType.list,
+              description: 'Column names to drop',
+            ),
+          ],
+        ),
+        handler: (args) async => registry.register(
+          registry.get(_handle(args)).drop(_castStringList(args['columns'])!),
+        ),
+      ),
+
+      HostFunction(
+        schema: const HostFunctionSchema(
+          name: 'df_rename',
+          description: 'Rename columns, return new handle.',
+          params: [
+            _handleParam,
+            HostParam(
+              name: 'mapping',
+              type: HostParamType.map,
+              description: 'Map of old name to new name',
+            ),
+          ],
+        ),
+        handler: (args) async => registry.register(
+          registry.get(_handle(args)).rename(
+                Map<String, String>.from(
+                  args['mapping']! as Map<String, Object?>,
+                ),
+              ),
+        ),
+      ),
+
+      HostFunction(
+        schema: const HostFunctionSchema(
+          name: 'df_merge',
+          description: 'Merge two DataFrames on columns, return new handle.',
+          params: [
+            _handleParam,
+            HostParam(
+              name: 'other_handle',
+              type: HostParamType.number,
+              description: 'Handle of other DataFrame',
+            ),
+            HostParam(
+              name: 'on',
+              type: HostParamType.list,
+              description: 'Join column names',
+            ),
+            HostParam(
+              name: 'how',
+              type: HostParamType.string,
+              isRequired: false,
+              defaultValue: 'inner',
+              description: 'Join type: inner or left',
+            ),
+          ],
+        ),
+        handler: (args) async => registry.register(
+          registry.get(_handle(args)).merge(
+                registry.get((args['other_handle']! as num).toInt()),
+                _castStringList(args['on'])!,
+                how: args['how'] as String? ?? 'inner',
+              ),
+        ),
+      ),
+
+      HostFunction(
+        schema: const HostFunctionSchema(
+          name: 'df_concat',
+          description: 'Concatenate DataFrames, return new handle.',
+          params: [
+            HostParam(
+              name: 'handles',
+              type: HostParamType.list,
+              description: 'List of DataFrame handles to concatenate',
+            ),
+          ],
+        ),
+        handler: (args) async {
+          final handles = (args['handles']! as List<Object?>)
+              .cast<num>()
+              .map((h) => registry.get(h.toInt()))
+              .toList();
+          final first = handles.first;
+          return registry.register(first.concat(handles.skip(1).toList()));
+        },
+      ),
+
+      HostFunction(
+        schema: const HostFunctionSchema(
+          name: 'df_fillna',
+          description: 'Fill null values, return new handle.',
+          params: [
+            _handleParam,
+            HostParam(
+              name: 'value',
+              type: HostParamType.any,
+              isRequired: false,
+              description: 'Replacement value',
+            ),
+          ],
+        ),
+        handler: (args) async => registry.register(
+          registry.get(_handle(args)).fillna(args['value']),
+        ),
+      ),
+
+      HostFunction(
+        schema: const HostFunctionSchema(
+          name: 'df_dropna',
+          description: 'Drop rows with null values, return new handle.',
+          params: [_handleParam],
+        ),
+        handler: (args) async =>
+            registry.register(registry.get(_handle(args)).dropna()),
+      ),
+
+      HostFunction(
+        schema: const HostFunctionSchema(
+          name: 'df_transpose',
+          description: 'Transpose DataFrame, return new handle.',
+          params: [_handleParam],
+        ),
+        handler: (args) async =>
+            registry.register(registry.get(_handle(args)).transpose()),
+      ),
+
+      HostFunction(
+        schema: const HostFunctionSchema(
+          name: 'df_sample',
+          description: 'Random sample of n rows, return new handle.',
+          params: [
+            _handleParam,
+            HostParam(
+              name: 'n',
+              type: HostParamType.number,
+              description: 'Number of rows to sample',
+            ),
+          ],
+        ),
+        handler: (args) async => registry.register(
+          registry.get(_handle(args)).sample((args['n']! as num).toInt()),
+        ),
+      ),
+
+      HostFunction(
+        schema: const HostFunctionSchema(
+          name: 'df_nlargest',
+          description: 'Largest n rows by column, return new handle.',
+          params: [
+            _handleParam,
+            HostParam(
+              name: 'n',
+              type: HostParamType.number,
+              description: 'Number of rows',
+            ),
+            HostParam(
+              name: 'column',
+              type: HostParamType.string,
+              description: 'Column to sort by',
+            ),
+          ],
+        ),
+        handler: (args) async => registry.register(
+          registry.get(_handle(args)).nlargest(
+                (args['n']! as num).toInt(),
+                args['column']! as String,
+              ),
+        ),
+      ),
+
+      HostFunction(
+        schema: const HostFunctionSchema(
+          name: 'df_nsmallest',
+          description: 'Smallest n rows by column, return new handle.',
+          params: [
+            _handleParam,
+            HostParam(
+              name: 'n',
+              type: HostParamType.number,
+              description: 'Number of rows',
+            ),
+            HostParam(
+              name: 'column',
+              type: HostParamType.string,
+              description: 'Column to sort by',
+            ),
+          ],
+        ),
+        handler: (args) async => registry.register(
+          registry.get(_handle(args)).nsmallest(
+                (args['n']! as num).toInt(),
+                args['column']! as String,
+              ),
+        ),
+      ),
+
+      // -- Aggregate (8) -----------------------------------------------------
+
+      HostFunction(
+        schema: const HostFunctionSchema(
+          name: 'df_mean',
+          description: 'Mean of a column (or all numeric columns).',
+          params: [
+            _handleParam,
+            HostParam(
+              name: 'column',
+              type: HostParamType.string,
+              isRequired: false,
+              description: 'Column name (omit for all)',
+            ),
+          ],
+        ),
+        handler: (args) async =>
+            registry.get(_handle(args)).computeMean(args['column'] as String?),
+      ),
+
+      HostFunction(
+        schema: const HostFunctionSchema(
+          name: 'df_sum',
+          description: 'Sum of a column (or all numeric columns).',
+          params: [
+            _handleParam,
+            HostParam(
+              name: 'column',
+              type: HostParamType.string,
+              isRequired: false,
+              description: 'Column name (omit for all)',
+            ),
+          ],
+        ),
+        handler: (args) async =>
+            registry.get(_handle(args)).computeSum(args['column'] as String?),
+      ),
+
+      HostFunction(
+        schema: const HostFunctionSchema(
+          name: 'df_min',
+          description: 'Min of a column (or all numeric columns).',
+          params: [
+            _handleParam,
+            HostParam(
+              name: 'column',
+              type: HostParamType.string,
+              isRequired: false,
+              description: 'Column name (omit for all)',
+            ),
+          ],
+        ),
+        handler: (args) async =>
+            registry.get(_handle(args)).computeMin(args['column'] as String?),
+      ),
+
+      HostFunction(
+        schema: const HostFunctionSchema(
+          name: 'df_max',
+          description: 'Max of a column (or all numeric columns).',
+          params: [
+            _handleParam,
+            HostParam(
+              name: 'column',
+              type: HostParamType.string,
+              isRequired: false,
+              description: 'Column name (omit for all)',
+            ),
+          ],
+        ),
+        handler: (args) async =>
+            registry.get(_handle(args)).computeMax(args['column'] as String?),
+      ),
+
+      HostFunction(
+        schema: const HostFunctionSchema(
+          name: 'df_std',
+          description:
+              'Standard deviation of a column (or all numeric columns).',
+          params: [
+            _handleParam,
+            HostParam(
+              name: 'column',
+              type: HostParamType.string,
+              isRequired: false,
+              description: 'Column name (omit for all)',
+            ),
+          ],
+        ),
+        handler: (args) async =>
+            registry.get(_handle(args)).computeStd(args['column'] as String?),
+      ),
+
+      HostFunction(
+        schema: const HostFunctionSchema(
+          name: 'df_corr',
+          description:
+              'Correlation matrix for numeric columns, return new handle.',
+          params: [_handleParam],
+        ),
+        handler: (args) async =>
+            registry.register(registry.get(_handle(args)).corr()),
+      ),
+
+      HostFunction(
+        schema: const HostFunctionSchema(
+          name: 'df_unique',
+          description: 'Unique values in a column.',
+          params: [
+            _handleParam,
+            HostParam(
+              name: 'column',
+              type: HostParamType.string,
+              description: 'Column name',
+            ),
+          ],
+        ),
+        handler: (args) async =>
+            registry.get(_handle(args)).unique(args['column']! as String),
+      ),
+
+      HostFunction(
+        schema: const HostFunctionSchema(
+          name: 'df_value_counts',
+          description: 'Value counts for a column.',
+          params: [
+            _handleParam,
+            HostParam(
+              name: 'column',
+              type: HostParamType.string,
+              description: 'Column name',
+            ),
+          ],
+        ),
+        handler: (args) async =>
+            registry.get(_handle(args)).valueCounts(args['column']! as String),
+      ),
+
+      // -- Lifecycle (2) -----------------------------------------------------
+
+      HostFunction(
+        schema: const HostFunctionSchema(
+          name: 'df_dispose',
+          description: 'Dispose a single DataFrame handle.',
+          params: [_handleParam],
+        ),
+        handler: (args) async {
+          registry.dispose(_handle(args));
+          return null;
+        },
+      ),
+
+      HostFunction(
+        schema: const HostFunctionSchema(
+          name: 'df_dispose_all',
+          description: 'Dispose all DataFrame handles.',
+        ),
+        handler: (args) async {
+          registry.disposeAll();
+          return null;
+        },
+      ),
+    ];
+
+// -- Shared helpers --------------------------------------------------------
+
+/// Common parameter for DataFrame handle.
+const _handleParam = HostParam(
+  name: 'handle',
+  type: HostParamType.number,
+  description: 'DataFrame handle ID',
+);
+
+/// Extract handle as int from args map.
+int _handle(Map<String, Object?> args) => (args['handle']! as num).toInt();
+
+/// Convert a nullable num to int with a default.
+int _intOr(Object? v, int defaultValue) =>
+    v != null ? (v as num).toInt() : defaultValue;
+
+/// Cast a nullable [Object] to `List<String>` for column-name args.
+List<String>? _castStringList(Object? v) {
+  if (v == null) return null;
+  return (v as List<Object?>).cast<String>();
+}
diff --git a/packages/soliplex_scripting/lib/src/host_function_wiring.dart b/packages/soliplex_scripting/lib/src/host_function_wiring.dart
index d25053a..5c9b93e 100644
--- a/packages/soliplex_scripting/lib/src/host_function_wiring.dart
+++ b/packages/soliplex_scripting/lib/src/host_function_wiring.dart
@@ -1,5 +1,7 @@
 import 'package:soliplex_agent/soliplex_agent.dart' show HostApi;
+import 'package:soliplex_dataframe/soliplex_dataframe.dart';
 import 'package:soliplex_interpreter_monty/soliplex_interpreter_monty.dart';
+import 'package:soliplex_scripting/src/df_functions.dart';
 
 /// Wires [HostApi] methods to [HostFunction]s and registers them onto a
 /// [MontyBridge] via a [HostFunctionRegistry].
@@ -9,72 +11,32 @@ import 'package:soliplex_interpreter_monty/soliplex_interpreter_monty.dart';
 ///
 /// | Category | Python name    | HostApi method       |
 /// |----------|---------------|----------------------|
-/// | data     | `df_create`   | `registerDataFrame`  |
-/// | data     | `df_get`      | `getDataFrame`       |
+/// | df       | `df_*` (37)   | via DfRegistry       |
 /// | chart    | `chart_create`| `registerChart`      |
 /// | platform | `host_invoke` | `invoke`             |
 class HostFunctionWiring {
-  HostFunctionWiring({required HostApi hostApi}) : _hostApi = hostApi;
+  HostFunctionWiring({
+    required HostApi hostApi,
+    DfRegistry? dfRegistry,
+  })  : _hostApi = hostApi,
+        _dfRegistry = dfRegistry ?? DfRegistry();
 
   final HostApi _hostApi;
+  final DfRegistry _dfRegistry;
+
+  /// The [DfRegistry] backing all df_* operations for this wiring.
+  DfRegistry get dfRegistry => _dfRegistry;
 
   /// Registers all host function categories (plus introspection builtins)
   /// onto [bridge].
   void registerOnto(MontyBridge bridge) {
     (HostFunctionRegistry()
-          ..addCategory('data', _dataFunctions())
+          ..addCategory('df', buildDfFunctions(_dfRegistry))
           ..addCategory('chart', _chartFunctions())
           ..addCategory('platform', _platformFunctions()))
         .registerAllOnto(bridge);
   }
 
-  List<HostFunction> _dataFunctions() => [
-        HostFunction(
-          schema: const HostFunctionSchema(
-            name: 'df_create',
-            description: 'Create a DataFrame from column data.',
-            params: [
-              HostParam(
-                name: 'columns',
-                type: HostParamType.map,
-                description: 'Column name to values mapping.',
-              ),
-            ],
-          ),
-          handler: (args) async {
-            final raw = args['columns'];
-            if (raw is! Map) {
-              throw ArgumentError.value(raw, 'columns', 'Expected a map.');
-            }
-            return _hostApi.registerDataFrame(_castColumns(raw));
-          },
-        ),
-        HostFunction(
-          schema: const HostFunctionSchema(
-            name: 'df_get',
-            description: 'Retrieve a DataFrame by handle.',
-            params: [
-              HostParam(
-                name: 'handle',
-                type: HostParamType.integer,
-                description: 'Integer handle returned by df_create.',
-              ),
-            ],
-          ),
-          handler: (args) async {
-            final handle = args['handle'];
-            if (handle is! int) {
-              throw ArgumentError.value(
-                handle,
-                'handle',
-                'Expected an integer.',
-              );
-            }
-            return _hostApi.getDataFrame(handle);
-          },
-        ),
-      ];
-
   List<HostFunction> _chartFunctions() => [
         HostFunction(
           schema: const HostFunctionSchema(
@@ -129,30 +91,4 @@ class HostFunctionWiring {
           },
         ),
       ];
-
-  /// Casts a raw map (from Python dict) to the typed column map that
-  /// [HostApi.registerDataFrame] expects.
-  ///
-  /// Throws [ArgumentError] if keys are not strings or values are not lists.
-  static Map<String, List<Object?>> _castColumns(Map<dynamic, dynamic> raw) {
-    final result = <String, List<Object?>>{};
-    for (final entry in raw.entries) {
-      if (entry.key is! String) {
-        throw ArgumentError.value(
-          entry.key,
-          'columns key',
-          'Expected a string.',
-        );
-      }
-      if (entry.value is! List) {
-        throw ArgumentError.value(
-          entry.value,
-          'columns["${entry.key}"]',
-          'Expected a list.',
-        );
-      }
-      result[entry.key as String] = List<Object?>.from(entry.value as List);
-    }
-    return result;
-  }
 }
diff --git a/packages/soliplex_scripting/pubspec.yaml b/packages/soliplex_scripting/pubspec.yaml
index 5c64925..9236d2a 100644
--- a/packages/soliplex_scripting/pubspec.yaml
+++ b/packages/soliplex_scripting/pubspec.yaml
@@ -16,6 +16,8 @@ dependencies:
     path: ../soliplex_agent
   soliplex_client:
     path: ../soliplex_client
+  soliplex_dataframe:
+    path: ../soliplex_dataframe
   soliplex_interpreter_monty:
     path: ../soliplex_interpreter_monty
 
diff --git a/packages/soliplex_scripting/test/src/bridge_cache_test.dart b/packages/soliplex_scripting/test/src/bridge_cache_test.dart
index cf2fcfe..6a7c9ae 100644
--- a/packages/soliplex_scripting/test/src/bridge_cache_test.dart
+++ b/packages/soliplex_scripting/test/src/bridge_cache_test.dart
@@ -1,3 +1,4 @@
+import 'package:soliplex_dataframe/soliplex_dataframe.dart';
 import 'package:soliplex_interpreter_monty/soliplex_interpreter_monty.dart';
 import 'package:soliplex_scripting/soliplex_scripting.dart';
 import 'package:test/test.dart';
@@ -219,6 +220,57 @@ void main() {
       });
     });
 
+    group('registryFor', () {
+      test('creates DfRegistry on first call', () {
+        final reg = cache.registryFor(_key1);
+        expect(reg, isA<DfRegistry>());
+      });
+
+      test('returns same registry for same key', () {
+        final reg1 = cache.registryFor(_key1);
+        final reg2 = cache.registryFor(_key1);
+        expect(identical(reg1, reg2), isTrue);
+      });
+
+      test('returns different registry for different key', () {
+        final reg1 = cache.registryFor(_key1);
+        final reg2 = cache.registryFor(_key2);
+        expect(identical(reg1, reg2), isFalse);
+      });
+
+      test('evict cleans up registry', () {
+        cache
+          ..acquire(_key1)
+          ..release(_key1);
+        cache.registryFor(_key1).register(
+              const DataFrame([
+                {'a': 1},
+              ]),
+            );
+
+        cache.evict(_key1);
+
+        // After evict, registryFor returns a fresh registry.
+        final newReg = cache.registryFor(_key1);
+        expect(
+          identical(cache.registryFor(_key1), newReg),
+          isTrue,
+        );
+      });
+
+      test('disposeAll cleans up all registries', () {
+        cache
+          ..registryFor(_key1)
+          ..registryFor(_key2)
+          ..acquire(_key1)
+          ..acquire(_key2)
+          ..disposeAll();
+
+        // Fresh registries after disposeAll.
+        expect(cache.registryFor(_key1), isA<DfRegistry>());
+      });
+    });
+
     group('limit = 1 (WASM scenario)', () {
       late BridgeCache wasmCache;
 
diff --git a/packages/soliplex_scripting/test/src/df_functions_test.dart b/packages/soliplex_scripting/test/src/df_functions_test.dart
new file mode 100644
index 0000000..c5b1035
--- /dev/null
+++ b/packages/soliplex_scripting/test/src/df_functions_test.dart
@@ -0,0 +1,186 @@
+import 'package:soliplex_dataframe/soliplex_dataframe.dart';
+import 'package:soliplex_scripting/soliplex_scripting.dart';
+import 'package:test/test.dart';
+
+void main() {
+  group('buildDfFunctions', () {
+    late DfRegistry registry;
+
+    setUp(() {
+      registry = DfRegistry();
+    });
+
+    test('returns 37 functions', () {
+      final fns = buildDfFunctions(registry);
+      expect(fns, hasLength(37));
+    });
+
+    test('all function names are unique', () {
+      final fns = buildDfFunctions(registry);
+      final names = fns.map((f) => f.schema.name).toSet();
+      expect(names, hasLength(37));
+    });
+
+    group('schema coverage', () {
+      test('df_create has data and columns params', () {
+        final fns = buildDfFunctions(registry);
+        final create = fns.firstWhere((f) => f.schema.name == 'df_create');
+        final paramNames = create.schema.params.map((p) => p.name).toList();
+        expect(paramNames, ['data', 'columns']);
+        expect(create.schema.params[0].isRequired, isTrue);
+        expect(create.schema.params[1].isRequired, isFalse);
+      });
+
+      test('df_filter has handle, column, op, value params', () {
+        final fns = buildDfFunctions(registry);
+        final filter = fns.firstWhere((f) => f.schema.name == 'df_filter');
+        final paramNames = filter.schema.params.map((p) => p.name).toList();
+        expect(paramNames, ['handle', 'column', 'op', 'value']);
+      });
+
+      test('df_dispose_all has no params', () {
+        final fns = buildDfFunctions(registry);
+        final disposeAll =
+            fns.firstWhere((f) => f.schema.name == 'df_dispose_all');
+        expect(disposeAll.schema.params, isEmpty);
+      });
+    });
+
+    group('handler smoke tests', () {
+      test('df_create returns a handle', () async {
+        final fns = buildDfFunctions(registry);
+        final create = fns.firstWhere((f) => f.schema.name == 'df_create');
+        final handle = await create.handler({
+          'data': <Object?>[
+            <String, Object?>{'a': 1, 'b': 2},
+            <String, Object?>{'a': 3, 'b': 4},
+          ],
+          'columns': null,
+        });
+        expect(handle, isA<int>());
+        expect(handle! as int, isPositive);
+      });
+
+      test('df_head returns rows', () async {
+        final fns = buildDfFunctions(registry);
+        final create = fns.firstWhere((f) => f.schema.name == 'df_create');
+        final head = fns.firstWhere((f) => f.schema.name == 'df_head');
+
+        final handle = (await create.handler({
+          'data': <Object?>[
+            <String, Object?>{'x': 1},
+            <String, Object?>{'x': 2},
+            <String, Object?>{'x': 3},
+          ],
+          'columns': null,
+        }))! as int;
+
+        final rows = await head.handler({
+          'handle': handle,
+          'n': 2,
+        });
+        expect(rows, isA<List<Object?>>());
+        expect((rows! as List<Object?>).length, 2);
+      });
+
+      test('df_shape returns [rows, cols]', () async {
+        final fns = buildDfFunctions(registry);
+        final create = fns.firstWhere((f) => f.schema.name == 'df_create');
+        final shape = fns.firstWhere((f) => f.schema.name == 'df_shape');
+
+        final handle = (await create.handler({
+          'data': <Object?>[
+            <String, Object?>{'a': 1, 'b': 2},
+          ],
+          'columns': null,
+        }))! as int;
+
+        final result = await shape.handler({'handle': handle});
+        expect(result, [1, 2]);
+      });
+
+      test('df_dispose returns null', () async {
+        final fns = buildDfFunctions(registry);
+        final create = fns.firstWhere((f) => f.schema.name == 'df_create');
+        final dispose = fns.firstWhere((f) => f.schema.name == 'df_dispose');
+
+        final handle = (await create.handler({
+          'data': <Object?>[
+            <String, Object?>{'a': 1},
+          ],
+          'columns': null,
+        }))! as int;
+
+        final result = await dispose.handler({'handle': handle});
+        expect(result, isNull);
+      });
+
+      test('df_dispose_all returns null', () async {
+        final fns = buildDfFunctions(registry);
+        final disposeAll =
+            fns.firstWhere((f) => f.schema.name == 'df_dispose_all');
+
+        final result = await disposeAll.handler({});
+        expect(result, isNull);
+      });
+
+      test('df_filter creates filtered DataFrame', () async {
+        final fns = buildDfFunctions(registry);
+        final create = fns.firstWhere((f) => f.schema.name == 'df_create');
+        final filter = fns.firstWhere((f) => f.schema.name == 'df_filter');
+        final head = fns.firstWhere((f) => f.schema.name == 'df_head');
+
+        final handle = (await create.handler({
+          'data': <Object?>[
+            <String, Object?>{'name': 'Alice', 'age': 30},
+            <String, Object?>{'name': 'Bob', 'age': 25},
+            <String, Object?>{'name': 'Carol', 'age': 35},
+          ],
+          'columns': null,
+        }))! as int;
+
+        final filteredHandle = (await filter.handler({
+          'handle': handle,
+          'column': 'age',
+          'op': '>',
+          'value': 28,
+        }))! as int;
+
+        final rows = (await head.handler({
+          'handle': filteredHandle,
+          'n': 10,
+        }))! as List<Object?>;
+
+        expect(rows.length, 2);
+      });
+
+      test('df_concat merges multiple DataFrames', () async {
+        final fns = buildDfFunctions(registry);
+        final create = fns.firstWhere((f) => f.schema.name == 'df_create');
+        final concat = fns.firstWhere((f) => f.schema.name == 'df_concat');
+        final shape = fns.firstWhere((f) => f.schema.name == 'df_shape');
+
+        final h1 = (await create.handler({
+          'data': <Object?>[
+            <String, Object?>{'x': 1},
+          ],
+          'columns': null,
+        }))! as int;
+        final h2 = (await create.handler({
+          'data': <Object?>[
+            <String, Object?>{'x': 2},
+            <String, Object?>{'x': 3},
+          ],
+          'columns': null,
+        }))! as int;
+
+        final concatHandle = (await concat.handler({
+          'handles': <Object?>[h1, h2],
+        }))! as int;
+
+        final result = await shape.handler({'handle': concatHandle});
+        expect(result, [3, 1]);
+      });
+    });
+  });
+}
diff --git a/packages/soliplex_scripting/test/src/host_function_wiring_test.dart b/packages/soliplex_scripting/test/src/host_function_wiring_test.dart
index 7a348a0..964fa71 100644
--- a/packages/soliplex_scripting/test/src/host_function_wiring_test.dart
+++ b/packages/soliplex_scripting/test/src/host_function_wiring_test.dart
@@ -1,4 +1,5 @@
 import 'package:soliplex_agent/soliplex_agent.dart' show HostApi;
+import 'package:soliplex_dataframe/soliplex_dataframe.dart';
 import 'package:soliplex_interpreter_monty/soliplex_interpreter_monty.dart';
 import 'package:soliplex_scripting/soliplex_scripting.dart';
 import 'package:test/test.dart';
@@ -68,29 +69,32 @@ void main() {
       wiring = HostFunctionWiring(hostApi: hostApi);
     });
 
-    test('registerOnto registers the 4 host functions + introspection', () {
+    test('registerOnto registers df + chart + platform + introspection', () {
       wiring.registerOnto(bridge);
 
       final names = bridge.registered.map((f) => f.schema.name).toSet();
-      // 4 domain functions + 2 introspection builtins
-      expect(names, containsAll(['df_create', 'df_get', 'chart_create']));
+      // 37 df + 1 chart + 1 platform + 2 introspection = 41
+      expect(bridge.registered, hasLength(41));
+      expect(names, contains('df_create'));
+      expect(names, contains('df_head'));
+      expect(names, contains('df_filter'));
+      expect(names, contains('chart_create'));
       expect(names, contains('host_invoke'));
       expect(names, contains('list_functions'));
       expect(names, contains('help'));
-      expect(bridge.registered, hasLength(6));
     });
 
-    test('registers correct function names', () {
-      wiring.registerOnto(bridge);
+    test('exposes dfRegistry', () {
+      expect(wiring.dfRegistry, isA<DfRegistry>());
+    });
 
-      final names = bridge.registered.map((f) => f.schema.name).toList();
-      // Domain functions appear before introspection builtins.
-      expect(names.sublist(0, 4), [
-        'df_create',
-        'df_get',
-        'chart_create',
-        'host_invoke',
-      ]);
+    test('accepts injected DfRegistry', () {
+      final registry = DfRegistry();
+      final custom = HostFunctionWiring(
+        hostApi: hostApi,
+        dfRegistry: registry,
+      );
+      expect(custom.dfRegistry, same(registry));
     });
 
     group('handler delegation', () {
@@ -103,22 +107,35 @@ void main() {
         };
       });
 
-      test('df_create delegates to HostApi.registerDataFrame', () async {
+      test('df_create creates via DfRegistry', () async {
         final result = await byName['df_create']!.handler({
-          'columns': <String, Object?>{
-            'a': [1, 2],
-          },
+          'data': <Object?>[
+            <String, Object?>{'a': 1, 'b': 2},
+          ],
+          'columns': null,
         });
 
-        expect(result, 42);
-        expect(hostApi.calls, contains('registerDataFrame'));
+        expect(result, isA<int>());
+        expect(result! as int, isPositive);
       });
 
-      test('df_get delegates to HostApi.getDataFrame', () async {
-        final result = await byName['df_get']!.handler({'handle': 5});
-
-        expect(result, isA<Map<String, List<Object?>>>());
-        expect(hostApi.calls['getDataFrame'], [5]);
+      test('df_head returns rows', () async {
+        // First create a DataFrame
+        final handle = (await byName['df_create']!.handler({
+          'data': <Object?>[
+            <String, Object?>{'x': 1},
+            <String, Object?>{'x': 2},
+            <String, Object?>{'x': 3},
+          ],
+          'columns': null,
+        }))! as int;
+
+        final rows = await byName['df_head']!.handler({
+          'handle': handle,
+          'n': 2,
+        });
+        expect(rows, isA<List<Object?>>());
+        expect((rows! as List<Object?>).length, 2);
       });
 
       test('chart_create delegates to HostApi.registerChart', () async {
diff --git a/packages/soliplex_scripting/test/src/integration_test.dart b/packages/soliplex_scripting/test/src/integration_test.dart
index d4dbf63..55e0e84 100644
--- a/packages/soliplex_scripting/test/src/integration_test.dart
+++ b/packages/soliplex_scripting/test/src/integration_test.dart
@@ -138,19 +138,15 @@ void main() {
         id: 'tc-integration',
         name: PythonExecutorTool.toolName,
         arguments: jsonEncode({
-          'code': 'df_create({"columns": {"x": [1, 2, 3]}})',
+          'code': 'df_create({"data": [{"x": 1}, {"x": 2}, {"x": 3}],'
+              ' "columns": null})',
         }),
       );
 
       final result = await executor.execute(toolCall);
 
-      expect(hostApi.calls, contains('registerDataFrame'));
-      expect(
-        hostApi.calls['registerDataFrame']![0],
-        {
-          'x': [1, 2, 3],
-        },
-      );
+      // df_create now uses DfRegistry, not HostApi.registerDataFrame.
+      // Verify it returned a handle (integer) via the bridge output.
       expect(result, 'done');
       expect(cache.isExecuting(_key), isFalse);
 
diff --git a/packages/soliplex_scripting/test/src/monty_tool_executor_test.dart b/packages/soliplex_scripting/test/src/monty_tool_executor_test.dart
index d880d17..bacae74 100644
--- a/packages/soliplex_scripting/test/src/monty_tool_executor_test.dart
+++ b/packages/soliplex_scripting/test/src/monty_tool_executor_test.dart
@@ -177,8 +177,8 @@ void main() {
         );
 
         await executor.execute(_toolCall('x = 1'));
-        // 4 domain functions + 2 introspection builtins
-        expect(bridge.registered, hasLength(6));
+        // 37 df + 1 chart + 1 platform + 2 introspection = 41
+        expect(bridge.registered, hasLength(41));
       });
 
       test('releases bridge even on error', () async {
diff --git a/pubspec.lock b/pubspec.lock
index d02376a..a5a4d64 100644
--- a/pubspec.lock
+++ b/pubspec.lock
@@ -186,6 +186,13 @@ packages:
       url: "https://pub.dev"
     source: hosted
     version: "1.0.8"
+  dart_monty_platform_interface:
+    dependency: transitive
+    description:
+      path: "/Users/runyaga/dev/dart_monty/packages/dart_monty_platform_interface"
+      relative: false
+    source: path
+    version: "0.6.1"
   dbus:
     dependency: transitive
     description:
@@ -906,6 +913,20 @@ packages:
       relative: true
     source: path
     version: "1.0.0-dev"
+  soliplex_dataframe:
+    dependency: "direct main"
+    description:
+      path: "packages/soliplex_dataframe"
+      relative: true
+    source: path
+    version: "0.1.0"
+  soliplex_interpreter_monty:
+    dependency: transitive
+    description:
+      path: "packages/soliplex_interpreter_monty"
+      relative: true
+    source: path
+    version: "0.1.0"
   soliplex_logging:
     dependency: "direct main"
     description:
@@ -913,6 +934,13 @@ packages:
       relative: true
     source: path
     version: "0.1.0"
+  soliplex_scripting:
+    dependency: "direct main"
+    description:
+      path: "packages/soliplex_scripting"
+      relative: true
+    source: path
+    version: "0.1.0"
   source_map_stack_trace:
     dependency: transitive
     description:
diff --git a/pubspec.yaml b/pubspec.yaml
index 264661a..46966b0 100644
--- a/pubspec.yaml
+++ b/pubspec.yaml
@@ -35,8 +35,12 @@ dependencies:
     path: packages/soliplex_client
   soliplex_client_native:
     path: packages/soliplex_client_native
+  soliplex_dataframe:
+    path: packages/soliplex_dataframe
   soliplex_logging:
     path: packages/soliplex_logging
+  soliplex_scripting:
+    path: packages/soliplex_scripting
   url_launcher: ^6.3.2
   uuid: ^4.5.1
   wakelock_plus: ^1.4.0
