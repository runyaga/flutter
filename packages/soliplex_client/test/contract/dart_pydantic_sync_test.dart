import 'dart:convert';
import 'dart:io';
import 'package:flutter_test/flutter_test.dart';
import 'package:soliplex_client/src/generated/task_item.dart' as gen_task;
import 'package:soliplex_client/src/generated/task_list.dart' as gen_task_list;
import 'package:soliplex_client/src/generated/approval_request.dart'
    as gen_approval;

/// Contract tests to verify Dart models stay in sync with Python Pydantic models.
///
/// These tests load JSON fixtures (generated by the Python backend) and verify
/// that Dart can deserialize them correctly. This ensures the frontend and
/// backend maintain schema compatibility.
void main() {
  final fixturesDir = Directory('test/contract/fixtures');

  group('Dart-Pydantic contract sync', () {
    test('TaskItem deserializes Python fixture', () async {
      final fixture = File('${fixturesDir.path}/task_item.json');
      expect(fixture.existsSync(), isTrue,
          reason: 'Fixture file task_item.json must exist');

      final json =
          jsonDecode(await fixture.readAsString()) as Map<String, dynamic>;

      final task = gen_task.TaskItem.fromJson(json);

      // Verify all fields deserialize correctly
      expect(task.taskId, equals(json['task_id']));
      expect(task.title, equals(json['title']));
      expect(task.description, equals(json['description']));
      expect(task.status, equals(json['status']));
      expect(task.progressPct, equals(json['progress_pct']));
      expect(task.createdAt, equals(json['created_at']));
      expect(task.updatedAt, equals(json['updated_at']));
    });

    test('TaskItem serializes to match Python fixture', () async {
      final fixture = File('${fixturesDir.path}/task_item.json');
      final json =
          jsonDecode(await fixture.readAsString()) as Map<String, dynamic>;

      final task = gen_task.TaskItem.fromJson(json);
      final serialized = task.toJson();

      // Verify round-trip serialization matches original
      expect(serialized['task_id'], equals(json['task_id']));
      expect(serialized['title'], equals(json['title']));
      expect(serialized['description'], equals(json['description']));
      expect(serialized['status'], equals(json['status']));
      expect(serialized['progress_pct'], equals(json['progress_pct']));
      expect(serialized['created_at'], equals(json['created_at']));
      expect(serialized['updated_at'], equals(json['updated_at']));
    });

    test('TaskList deserializes Python fixture', () async {
      final fixture = File('${fixturesDir.path}/task_list.json');
      expect(fixture.existsSync(), isTrue,
          reason: 'Fixture file task_list.json must exist');

      final json =
          jsonDecode(await fixture.readAsString()) as Map<String, dynamic>;

      final taskList = gen_task_list.TaskList.fromJson(json);

      // Verify task list fields
      expect(taskList.missionId, equals(json['mission_id']));
      expect(taskList.tasks.length, equals((json['tasks'] as List).length));

      // Verify each task in the list
      final tasks = json['tasks'] as List;
      for (var i = 0; i < tasks.length; i++) {
        final expectedTask = tasks[i] as Map<String, dynamic>;
        final actualTask = taskList.tasks[i];

        expect(actualTask.taskId, equals(expectedTask['task_id']));
        expect(actualTask.title, equals(expectedTask['title']));
        expect(actualTask.description, equals(expectedTask['description']));
        expect(actualTask.status, equals(expectedTask['status']));
        expect(actualTask.progressPct, equals(expectedTask['progress_pct']));
      }
    });

    test('TaskList serializes to match Python fixture', () async {
      final fixture = File('${fixturesDir.path}/task_list.json');
      final json =
          jsonDecode(await fixture.readAsString()) as Map<String, dynamic>;

      final taskList = gen_task_list.TaskList.fromJson(json);
      final serialized = taskList.toJson();

      expect(serialized['mission_id'], equals(json['mission_id']));
      expect((serialized['tasks'] as List).length,
          equals((json['tasks'] as List).length));
    });

    test('ApprovalRequest deserializes Python fixture', () async {
      final fixture = File('${fixturesDir.path}/approval_request.json');
      expect(fixture.existsSync(), isTrue,
          reason: 'Fixture file approval_request.json must exist');

      final json =
          jsonDecode(await fixture.readAsString()) as Map<String, dynamic>;

      final approval = gen_approval.ApprovalRequest.fromJson(json);

      // Verify all fields deserialize correctly
      expect(approval.approvalId, equals(json['approval_id']));
      expect(approval.missionId, equals(json['mission_id']));
      expect(approval.actionType, equals(json['action_type']));
      expect(approval.title, equals(json['title']));
      expect(approval.description, equals(json['description']));
      expect(approval.status, equals(json['status']));
      expect(approval.createdAt, equals(json['created_at']));
      expect(approval.expiresAt, equals(json['expires_at']));

      // Verify payload map
      final expectedPayload = json['payload'] as Map<String, dynamic>;
      expect(approval.payload['file_path'], equals(expectedPayload['file_path']));
      expect(approval.payload['file_size'], equals(expectedPayload['file_size']));
    });

    test('ApprovalRequest serializes to match Python fixture', () async {
      final fixture = File('${fixturesDir.path}/approval_request.json');
      final json =
          jsonDecode(await fixture.readAsString()) as Map<String, dynamic>;

      final approval = gen_approval.ApprovalRequest.fromJson(json);
      final serialized = approval.toJson();

      expect(serialized['approval_id'], equals(json['approval_id']));
      expect(serialized['mission_id'], equals(json['mission_id']));
      expect(serialized['action_type'], equals(json['action_type']));
      expect(serialized['title'], equals(json['title']));
      expect(serialized['description'], equals(json['description']));
      expect(serialized['status'], equals(json['status']));
      expect(serialized['payload'], equals(json['payload']));
    });
  });

  group('Edge cases', () {
    test('TaskItem handles empty description', () {
      final json = {
        'task_id': 'test-001',
        'title': 'Test Task',
        'description': '',
        'status': 'pending',
        'progress_pct': 0,
        'created_at': '2026-01-25T10:00:00Z',
        'updated_at': '2026-01-25T10:00:00Z',
      };

      final task = gen_task.TaskItem.fromJson(json);
      expect(task.description, equals(''));
      expect(task.toJson()['description'], equals(''));
    });

    test('TaskList handles empty tasks list', () {
      final json = {
        'mission_id': 'mission-empty',
        'tasks': <Map<String, dynamic>>[],
      };

      final taskList = gen_task_list.TaskList.fromJson(json);
      expect(taskList.tasks, isEmpty);
      expect((taskList.toJson()['tasks'] as List), isEmpty);
    });

    test('ApprovalRequest handles empty payload', () {
      final json = {
        'approval_id': 'test-001',
        'mission_id': 'mission-001',
        'action_type': 'simple_action',
        'title': 'Simple Action',
        'description': 'A simple action',
        'status': 'pending',
        'payload': <String, dynamic>{},
        'created_at': '2026-01-25T10:00:00Z',
        'expires_at': '2026-01-25T10:05:00Z',
      };

      final approval = gen_approval.ApprovalRequest.fromJson(json);
      expect(approval.payload, isEmpty);
      expect(approval.toJson()['payload'], isEmpty);
    });
  });

  group('Schema version compatibility', () {
    test('TaskItem handles all known status values', () {
      final statuses = ['pending', 'in_progress', 'completed', 'failed', 'blocked'];

      for (final status in statuses) {
        final json = {
          'task_id': 'test-status',
          'title': 'Status Test',
          'description': 'Testing status: $status',
          'status': status,
          'progress_pct': 0,
          'created_at': '2026-01-25T10:00:00Z',
          'updated_at': '2026-01-25T10:00:00Z',
        };

        final task = gen_task.TaskItem.fromJson(json);
        expect(task.status, equals(status),
            reason: 'Should handle status: $status');
      }
    });

    test('ApprovalRequest handles various action types', () {
      final actionTypes = [
        'delete_file',
        'execute_command',
        'send_email',
        'api_call',
        'custom_action',
      ];

      for (final actionType in actionTypes) {
        final json = {
          'approval_id': 'test-action',
          'mission_id': 'mission-001',
          'action_type': actionType,
          'title': 'Action Test',
          'description': 'Testing action: $actionType',
          'status': 'pending',
          'payload': <String, dynamic>{},
          'created_at': '2026-01-25T10:00:00Z',
          'expires_at': '2026-01-25T10:05:00Z',
        };

        final approval = gen_approval.ApprovalRequest.fromJson(json);
        expect(approval.actionType, equals(actionType),
            reason: 'Should handle action_type: $actionType');
      }
    });
  });
}
