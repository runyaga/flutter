import 'package:dart_monty_platform_interface/dart_monty_platform_interface.dart';
import 'package:dart_monty_platform_interface/dart_monty_testing.dart';
import 'package:test/test.dart';

/// Generated by: python scripts/generate_monty_schemas.py --model tool
const _validateToolPython = '''
def validate_tool(raw):
    result = {}
    result['kind'] = str(raw.get('kind', ''))
    result['tool_name'] = str(raw.get('tool_name', ''))
    result['tool_description'] = str(raw.get('tool_description', ''))
    result['tool_requires'] = str(raw.get('tool_requires', ''))
    result['allow_mcp'] = bool(raw.get('allow_mcp', False))
    result['agui_feature_names'] = list(raw.get('agui_feature_names', []))
    result['extra_parameters'] = dict(raw.get('extra_parameters', {}))
    return result
''';

const _usage = MontyResourceUsage(
  memoryBytesUsed: 1024,
  timeElapsedMs: 10,
  stackDepthUsed: 5,
);

void main() {
  group('Schema spike: validate_tool via MontyPlatform.run()', () {
    late MockMontyPlatform mock;

    setUp(() {
      mock = MockMontyPlatform();
    });

    test('returns validated dict with correct types', () async {
      // Simulate what Monty would return: a Map with coerced values.
      mock.runResult = const MontyResult(
        value: {
          'kind': 'search',
          'tool_name': 'tools.search',
          'tool_description': 'Search indexed documents',
          'tool_requires': 'bare',
          'allow_mcp': false,
          'agui_feature_names': ['code_execution'],
          'extra_parameters': <String, Object?>{},
        },
        usage: _usage,
      );

      const code = '''
raw = __input__
$_validateToolPython
validate_tool(raw)
''';

      final result = await mock.run(
        code,
        inputs: {
          '__input__': {
            'kind': 'search',
            'tool_name': 'tools.search',
            'tool_description': 'Search indexed documents',
            'tool_requires': 'bare',
            'allow_mcp': false,
            'agui_feature_names': ['code_execution'],
            'extra_parameters': <String, Object?>{},
          },
        },
      );

      expect(result.error, isNull);

      final value = result.value! as Map<String, Object?>;
      expect(value['kind'], 'search');
      expect(value['tool_name'], 'tools.search');
      expect(value['tool_description'], 'Search indexed documents');
      expect(value['tool_requires'], 'bare');
      expect(value['allow_mcp'], false);
      expect(value['agui_feature_names'], ['code_execution']);
      expect(value['extra_parameters'], <String, Object?>{});
    });

    test('code sent to mock contains validate_tool function', () async {
      mock.runResult = const MontyResult(
        value: {
          'kind': '',
          'tool_name': '',
          'tool_description': '',
          'tool_requires': '',
          'allow_mcp': false,
          'agui_feature_names': <String>[],
          'extra_parameters': <String, Object?>{},
        },
        usage: _usage,
      );

      const code = '''
raw = __input__
$_validateToolPython
validate_tool(raw)
''';

      await mock.run(code, inputs: {'__input__': <String, Object?>{}});

      expect(mock.lastRunCode, contains('def validate_tool(raw):'));
      expect(mock.lastRunCode, contains('validate_tool(raw)'));
      expect(
        mock.lastRunInputs,
        containsPair('__input__', isA<Map<String, Object?>>()),
      );
    });

    test('handles missing fields with defaults', () async {
      // When raw input is empty, validator should fill defaults.
      mock.runResult = const MontyResult(
        value: {
          'kind': '',
          'tool_name': '',
          'tool_description': '',
          'tool_requires': '',
          'allow_mcp': false,
          'agui_feature_names': <String>[],
          'extra_parameters': <String, Object?>{},
        },
        usage: _usage,
      );

      const code = '''
raw = __input__
$_validateToolPython
validate_tool(raw)
''';

      final result = await mock.run(
        code,
        inputs: {'__input__': <String, Object?>{}},
      );

      expect(result.error, isNull);

      final value = result.value! as Map<String, Object?>;
      expect(value['kind'], '');
      expect(value['allow_mcp'], false);
      expect(value['agui_feature_names'], <String>[]);
      expect(value['extra_parameters'], <String, Object?>{});
    });

    test('coerces types from loosely-typed input', () async {
      // Monty's str(), bool(), list() coerce compatible types.
      mock.runResult = const MontyResult(
        value: {
          'kind': '42',
          'tool_name': '',
          'tool_description': '',
          'tool_requires': '',
          'allow_mcp': true,
          'agui_feature_names': <String>['a', 'b'],
          'extra_parameters': {'key': 'val'},
        },
        usage: _usage,
      );

      const code = '''
raw = __input__
$_validateToolPython
validate_tool(raw)
''';

      final result = await mock.run(
        code,
        inputs: {
          '__input__': {
            'kind': 42, // int → str
            'allow_mcp': 1, // int → bool
            'agui_feature_names': ['a', 'b'],
            'extra_parameters': {'key': 'val'},
          },
        },
      );

      expect(result.error, isNull);

      final value = result.value! as Map<String, Object?>;
      expect(value['kind'], '42');
      expect(value['allow_mcp'], true);
    });
  });
}
